 /***************************************************************************
 *   Copyright (C) 2007 by Abderrahman Taha                                *
 *                                                                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA            *
 ***************************************************************************/
#include "Iso3D.h"
using std::vector;
using std::list;




static int triTable_min[256][19] = {
 {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1},///<<<<<<<<<<<<<<
 {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
 {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
 ///{1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {1, 9, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},///<<<<<<<<<<<<<<
 {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
 {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
 ///{9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {9, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1}, ///<<<<<<<<<<<<<<
 ///{2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {2, 10, 9, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},    //(1, 5)
 {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1}, ///<<<<<<<<<<<<<<
 ///{0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {0, 8, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
 {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
  ///{1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  {1, 9, 8, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
  ///{3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
{3, 11, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
 ///{0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {0, 8, 11, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
  ///{3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
{3, 11, 10, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1}, //   //(1, 5)
  ///{9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
{9, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
 {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
  ///{4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
{4, 7, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1}, //(1, 4)
 {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
  ///{4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
{4, 7, 3, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
 {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
 ///{3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {3, 0, 4, 7, 1, 2, 10, -1,-1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
 ///{9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {9, 0, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
  ///{2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
    {2, 10, 9, 4, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
    {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
 ///{11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {11, 2, 0, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1}, //(1, 5)	
	{9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1}, //============================//
	///{4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, -1, -1, -1},
	{4, 7, 11, 2, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1}, //(1, 6)
	///{3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 11, 10, 1, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	///{1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, -1, -1, -1},
	{1, 0, 4, 7, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1}, //(1, 6)
	///{9, 0, 11, 9, 11, 10, 11, 0, 3, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 3, 11, 10, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  ///(2, 5, 3)
	///{4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 7, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	{9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	{9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	///{0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
	///{8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	{8, 3, 1, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	{1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	{3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1}, ///===================///
	///{5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5, 4, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, -1, -1, -1},
	{2, 10, 5, 4, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	{9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	///{0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 11, 2, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3}, //   //(2, 4, 3)
	///{2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
	{2, 1, 5, 4, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	///{10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
	{10, 1, 3, 11, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	///{4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
	{0, 8, 11, 10, 1, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  //(2, 5, 3)
	///{5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
	{5, 4, 0, 3, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	///{5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
	{5, 4, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
	///{9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 7, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)	
	///{0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 5, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1}, //(1, 4)
	///{9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 7, 8, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	///{9, 5, 0, 5, 3, 0, 5, 7, 3, 10, 1, 2, -1, -1, -1, -1},
	{9, 5, 7, 3, 0, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  //   //(2, 5, 3)	
	///{8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
	{8, 0, 2, 10, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1}, //   //(1, 6)
	///{2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
	{2, 10, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
	{7, 8, 9, 5, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
	{9, 5, 7, 11, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	 ///{2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
    {0, 1, 5, 7, 8, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  //(2, 5, 3)
	///{11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	{11, 2, 1, 5, 7, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
	{9, 5, 7, 8, 1, 3, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 4}, //   //(2, 4, 3)///================================================================================
	///{5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
	{5, 7, 11, 10, 1, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1}, //(1, 7)
	///{11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
	{11, 10, 5, 7, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1}, //(1, 7)
	///{11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 10, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1}, //   //(1, 4)
	{10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	{0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	{9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	///{1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	///{1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
	///{1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 6, 5, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	///{9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 2, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
	{5, 9, 8, 3, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	{2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	///{11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 2, 0, 8, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	{0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1}, //===============================//
	///{5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 8, 11, 2, 5, 10, 6, -1, 5, 10, 6, -1, -1, -1, -1, 2, 5, 3},  //(2, 5, 3)
	///{6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6, 5, 1, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 11, 6, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	///{3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, -1, -1, -1},
	{3, 11, 6, 5, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	///{6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
	{6, 5, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //   //(1, 5)
	{5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	///{4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
	{4, 7, 3, 0, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4,3)
	{1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1}, //================================//
	///{10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
	{1, 9, 4, 7, 3,  10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  //(2, 5, 3)
	///{6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
	{6, 5, 1, 2, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	///{1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
	{1, 2, 6, 5, 3, 0, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 4},  //(2, 4, 4)
	///{8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
	{9, 0, 2, 6, 5, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  //(2, 5, 3)
	///{7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
	{7, 3, 2, 6, 5, 9, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},  //(1, 7)
	{3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1}, //============================//
	///{5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
	{4, 7, 11, 2, 0, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  //(2, 5, 3)
	{0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 4, -1, -1}, ///++++++++++++++++++++++++++++++///
	///{9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
	{9, 4, 7, 11, 2, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 2, 6, 3},  //(2, 6, 3)
	///{8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, -1, -1, -1},
	{3, 11, 6, 5, 1, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  //(2, 5, 3)
	///{5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
	{5, 1, 0, 4, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1}, //   //(1, 7)
	///{0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
	{0, 3, 11, 6, 5, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 6, 3},  //(2, 6, 3)
	///{6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
	{6, 5, 9, 4, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	///{10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
	///{4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 10, 6, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	///{10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 4, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1}, //(1, 5)
	///{8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
	{8, 3, 1, 10, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	///{1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 6, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
	{1, 2, 6, 4, 9, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3}, //(2, 5, 3)
	///{0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
	///{8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
	{8, 3, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1}, //(1, 5)
	///{10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 4, 9, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},  //(2, 4, 3)
	///{0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
	{0, 8, 11, 2, 4, 9, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 4},  //(2, 4, 4)
	///{3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
	{0, 1, 10, 6, 4, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},  //(2, 5, 3)
	///{6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
	{6, 4, 8, 11, 2, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1}, //   //(1, 7)
	///{9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
	{9, 1, 3, 11, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1}, //   //(1, 6)
	///{8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
	{8, 11, 6, 4, 9, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},  //(1, 7)
	///{3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
	{3, 11, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6, 4, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},  //(1, 4)
	///{7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
	{7, 8, 9, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},  //(1, 5)
	///{0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
	{0, 9, 10, 6, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1}, //   //(1, 6)
	///{10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
	{10, 6, 7, 8, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},  //(1, 6)
	///{10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
	{1, 2, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
	{2, 6, 7, 3, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	///{7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
	{7, 8, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 3, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	///{2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
	{10, 6, 7, 8, 9, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	///{2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
	{2, 0, 9, 10, 6, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	///{1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
	{1, 10, 6, 7, 8, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 6, 3},   //(2, 6, 3)
	///{11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
	{11, 2, 1, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
	{8, 9, 1, 3, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	{0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	///{7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
	{7, 8, 0, 3, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	{7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	{7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	{3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	{0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	///{8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 3, 1, 9, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	{10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	{1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1}, //=======================//
	///{2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 10, 9, 0, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
	{ 2, 10, 9, 8, 3, 11, 7, 6, -1, -1, -1, -1,-1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	///{7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 6, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	///{7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
	{7, 6, 2, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 7, 6, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
	{1, 9, 8, 7, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
	{10, 1, 3, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
	{10, 1, 0, 8, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
	{0, 3, 7, 6, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
	 {7, 6, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	///{3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 4, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
	{8, 4, 6, 11, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
	{9, 4, 6, 11, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 8, 4, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
	{3, 0, 4, 6, 11, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	///{4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
	{4, 6, 11, 8, 0, 2, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 4},   //(2, 4, 4)
	///{10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
	{10, 9, 4, 6, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	///{8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
	{8, 4, 6, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	///{1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
	{2, 3, 8, 4, 6, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3}, //(2, 5, 3)
	///{1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
	{8, 4, 6, 10, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
	{10, 1, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
	{4, 6, 10, 9, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	///{10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 9, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	{4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	{0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1}, //============================//
	///{5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{5, 4, 0, 1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	{8, 3, 1, 5, 4, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	{9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1}, //============================//
	{6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 4, -1, -1}, //-------------------------------//
	///{7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
	{5, 4, 0, 2, 10, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	///{3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, -1, -1, -1},
	{3, 2, 10, 5, 4, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 2, 6, 3},   //(2, 6, 3)
	///{7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 6, 2, 3, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3) 
	///{9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
	{0, 8, 7, 6, 2, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3) 
	///{3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
	{3, 7, 6, 2, 1, 5, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 4},   //(2, 4, 4) 
	///{6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
	{6, 2, 1, 5, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7) 
	///{9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
	{10, 1, 3, 7, 6, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3) 
	///{1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
	{1, 0, 8, 7, 6, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 2, 6, 3},   //(2, 6, 3) 
	///{4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
	{4, 0, 3, 7, 6, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7) 
	///{7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
	{7, 6, 10, 5, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 8, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
	{3, 0, 9, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
	{0, 1, 5, 6, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
	{9, 5, 6, 11, 8, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	///{0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
	{0, 9, 5, 6, 11, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 2, 6, 3},   //(2, 6, 3) 
	///{11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
	{11, 8, 0, 2, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	///{6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
	{6, 11, 3, 2, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
	{5, 6, 2, 3, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
	{1, 5, 6, 2, 3, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	///{1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 5, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	///{1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
	{1, 3, 8, 9, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	///{10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
	{10, 1, 0, 9, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	{0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	{10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	///{11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 7, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	///{11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
	{11, 7, 5, 10, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 11, 7, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 3},   //(2, 4, 3)
	///{10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
	{10, 11, 7, 5, 9, 8, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 4},   //(2, 4, 4)
	///{11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
	{11, 7, 5, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
	{1, 2, 11, 7, 5, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	///{9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
	{9, 0, 2, 11, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
	{7, 5, 9, 8, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1,  7)
	///{2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 7, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
	{8, 7, 5, 10, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
	{5, 10, 2, 3, 7, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	///{9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
	{9, 8, 7, 5, 10, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	///{1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	///{0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	/// {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},    //(1, 5)
	/// {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 8, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	///{5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 11, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
    {5, 10, 11, 3, 0, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
	{8, 4, 5, 10, 11, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},    //(2, 5, 3)
	///{10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
	 {10, 11, 3, 1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	/// {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
	{2, 11, 8, 4, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	/// {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
	{0, 4, 5, 1, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	/// {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
	{0, 2, 11, 8, 4, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	{9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3}, ///<<<<<<<<<<
	///{2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, -1, -1, -1},
	 {2, 3, 8, 4, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	/// {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	/// {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
	{3, 8, 4, 5, 10, 2, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 2, 6, 3},   //(2, 6, 3)
	/// {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
	{5, 10, 2, 1, 9, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	/// {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
	{8, 4, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	/// {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 4, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	/// {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
	{8, 4, 5, 9, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	{9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	///{4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 10, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	/// {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 10, 11, 7, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 3},   //(2, 5, 3)
	/// {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
	{1, 10, 11, 7, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	/// {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
	{3, 1, 10, 11, 7, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	/// {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
	{4, 9, 1, 2, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	/// {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
	{9, 1, 2, 11, 7, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 2, 6, 3},   //(2, 6, 3)
	///{11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
	 {11, 7, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	/// {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
	{11, 7, 4, 8, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	///{2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
	 {2, 3, 7, 4, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	/// {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
	{9, 10, 2, 0, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	/// {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
	{3, 7, 4, 0, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 7, -1},   //(1, 7)
	{1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 3},///<<<<<<<<<<<<<<
	///{4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	 {4, 9, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
	 {4, 9, 1, 7, 8, 7, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, 2, 4, 4},   //(2, 4, 4)
	/// {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 0, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	{4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	/// {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	/// {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
	 {0, 1, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	 {3, 1, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	/// {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	///{3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
	 {3, 0, 9, 1, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	/// {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 2, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	{3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	/// {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, -1},   //(1, 5)
	/// {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 10, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	/// {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
	 {2, 3, 8, 0, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, -1},   //(1, 6)
	{1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	/// {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 3, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1},   //(1, 4)
	{0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	{0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, -1},///<<<<<<<<<<<<<<
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1}
};



static int triTable[256][16] = {
 {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 /// {1, 9, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
 {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 ///{9, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
 {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
 /// {2, 10, 9, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
 {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 /// {0, 8, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
 {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
 /// {1, 9, 8, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
 {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 ///{3, 11, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
 {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
 ///{0, 8, 11, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
 {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
 ///{3, 11, 10, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
 {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 ///{9, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
 {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 ///{4, 7, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
 {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
 ///{4, 7, 3, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
 {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
 ///{3, 0, 4, 7, 1, 2, 10, -1,-1, -1, -1, -1, -1, -1, -1, -1},  (2, 4, 3)
 {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
 ///{9, 0, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},  (2, 4, 3)
 {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
 ///{2, 10, 9, 4, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
 {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
 ///{11, 2, 0, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)	
	{9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
	{4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
	//{4, 7, 11, 2, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
	///{3, 11, 10, 1, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
	///{1, 0, 4, 7, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},  /// (1, 6)
	{9, 0, 11, 9, 11, 10, 11, 0, 3, 4, 7, 8, -1, -1, -1, -1},
	///{9, 0, 3, 11, 10, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1},  ///(2, 5, 3)
	{4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
	///{4, 7, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{0, 1, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	///{8, 3, 1, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
	{5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
	///{5, 4, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
	///{2, 10, 5, 4, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
	///{0, 8, 11, 2, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},  (2, 4, 3)
	{0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
	///{0, 1, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},  (2, 4, 3)
	{2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
	///{2, 1, 5, 4, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
	///{10, 1, 3, 11, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
	///{0, 8, 11, 10, 1, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
	///{5, 4, 0, 3, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
	///{5, 4, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{9, 5, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
	///{9, 5, 7, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)	
	{0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
	///{0, 1, 5, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{1, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
	///{9, 5, 7, 8, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{9, 5, 0, 5, 3, 0, 5, 7, 3, 10, 1, 2, -1, -1, -1, -1},
	///{9, 5, 7, 3, 0, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1},  (2, 5, 3)	
	{8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
	///{8, 0, 2, 10, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
	///{2, 10, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
	///{7, 8, 9, 5, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},  (2, 4, 3)
	{9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
	///{9, 5, 7, 11, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
    ///{0, 1, 5, 7, 8, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
	///{11, 2, 1, 5, 7, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
	///{9, 5, 7, 8, 1, 3, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
	///{5, 7, 11, 10, 1, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
	///{11, 10, 5, 7, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{11, 10, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
	///{1, 9, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{1, 2, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
	///{1, 2, 6, 5, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
	///{9, 0, 2, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
	///{5, 9, 8, 3, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},  (1, 6)
	{2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
	///{11, 2, 0, 8, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
	///{1, 9, 8, 11, 2, 5, 10, 6, -1, 5, 10, 6, -1, -1, -1, -1},  (2, 5, 3)
	{6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
	///{6, 5, 1, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
	///{0, 8, 11, 6, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
	///{3, 11, 6, 5, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
	///{6, 5, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},  (1, 5)
	{5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
	///{4, 7, 3, 0, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4,3)
	{1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
	{10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
	///{1, 9, 4, 7, 3,  10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
	///{6, 5, 1, 2, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
	///{1, 2, 6, 5, 3, 0, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 4)
	{8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
	///{9, 0, 2, 6, 5, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
	///{7, 3, 2, 6, 5, 9, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
	{5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
	///{4, 7, 11, 2, 0, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
	{9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
	///{9, 4, 7, 11, 2, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1}, (2, 6, 3)
	{8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
	///{3, 11, 6, 5, 1, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
	///{5, 1, 0, 4, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
	///{0, 3, 11, 6, 5, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1}, (2, 6, 3)
	{6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
	///{6, 5, 9, 4, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{10, 6, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
	///{4, 9, 10, 6, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
	///{10, 6, 4, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
	///{8, 3, 1, 10, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
	///{1, 2, 6, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
	///{1, 2, 6, 4, 9, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1},(2, 5, 3)
	{0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	//{0, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
	///{8, 3, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},(1, 5)
	{10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
	///{10, 6, 4, 9, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
	///{0, 8, 11, 2, 4, 9, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 4)
	{3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
	///{0, 1, 10, 6, 4, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
	///{6, 4, 8, 11, 2, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
	///{9, 1, 3, 11, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
	///{8, 11, 6, 4, 9, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
	///{3, 11, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{6, 4, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
	///{7, 8, 9, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
	///{0, 9, 10, 6, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
	///{10, 6, 7, 8, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
	///{10, 6, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
	///{1, 2, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
	///{2, 6, 7, 3, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
	///{7, 8, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{7, 3, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
	///{10, 6, 7, 8, 9, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
	///{2, 0, 9, 10, 6, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
	///{1, 10, 6, 7, 8, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1}, (2, 6, 3)
	{11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
	///{11, 2, 1, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
	///{8, 9, 1, 3, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1} (1, 7)
	{0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
	///{7, 8, 0, 3, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
	///{8, 3, 1, 9, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
	{2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
	///{2, 10, 9, 0, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
	///{ 2, 10, 9, 8, 3, 11, 7, 6, -1, -1, -1, -1,-1, -1, -1, -1}, (2, 5, 3)
	{7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{7, 6, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
	///{7, 6, 2, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
	///{2, 3, 7, 6, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
	///{1, 9, 8, 7, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
	///{10, 1, 3, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
	///{10, 1, 0, 8, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
	///{0, 3, 7, 6, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
	/// {7, 6, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{6, 11, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
	///{3, 0, 4, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
	///{8, 4, 6, 11, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
	///{9, 4, 6, 11, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
	///{6, 11, 8, 4, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
	///{3, 0, 4, 6, 11, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
	///{4, 6, 11, 8, 0, 2, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 4)
	{10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
	///{10, 9, 4, 6, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
	///{8, 4, 6, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{0, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
	///{2, 3, 8, 4, 6, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
	///{1, 9, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
	///{8, 4, 6, 10, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
	///{10, 1, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
	///{4, 6, 10, 9, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{10, 9, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
	{5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
	///{5, 4, 0, 1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
	///{8, 3, 1, 5, 4, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
	{6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
	{7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
	///{5, 4, 0, 2, 10, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
	///{3, 2, 10, 5, 4, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1}, (2, 6, 3)
	{7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
	///{7, 6, 2, 3, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3) 
	{9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
	///{0, 8, 7, 6, 2, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3) 
	{3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
	///{3, 7, 6, 2, 1, 5, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 4) 
	{6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
	///{6, 2, 1, 5, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7) 
	{9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
	///{10, 1, 3, 7, 6, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3) 
	{1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
	///{1, 0, 8, 7, 6, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1}, (2, 6, 3) 
	{4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
	///{4, 0, 3, 7, 6, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7) 
	{7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
	///{7, 6, 10, 5, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
	///{6, 11, 8, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
	///{3, 0, 9, 5, 6, 11, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1}, (1, 6)
	{0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
	///{0, 1, 5, 6, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
	///{6, 11, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
	///{9, 5, 6, 11, 8, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
	///{0, 9, 5, 6, 11, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1}, (2, 6, 3) 
	{11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
	///{11, 8, 0, 2, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
	///{6, 11, 3, 2, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
	///{5, 6, 2, 3, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
	///{9, 5, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
	///{1, 5, 6, 2, 3, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{1, 5, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
	///{1, 3, 8, 9, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
	///{10, 1, 0, 9, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{11, 7, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
	///{11, 7, 5, 10, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
	///{5, 10, 11, 7, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 3)
	{10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
	///{10, 11, 7, 5, 9, 8, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 4)
	{11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
	///{11, 7, 5, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
	///{1, 2, 11, 7, 5, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
	///{9, 0, 2, 11, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
	///{7, 5, 9, 8, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1,  7)
	{2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
	///{2, 3, 7, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
	///{8, 7, 5, 10, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
	///{5, 10, 2, 3, 7, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
	///{9, 8, 7, 5, 10, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	///{1, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
	///{0, 8, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
	/// {9, 0, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},  (1, 5)
	{9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	/// {9, 8, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
	///{5, 10, 11, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
    ///{5, 10, 11, 3, 0, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
	///{8, 4, 5, 10, 11, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1},  (2, 5, 3)
	{10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
	/// {10, 11, 3, 1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
	/// {2, 11, 8, 4, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
	/// {0, 4, 5, 1, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
	/// {0, 2, 11, 8, 4, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
	/// {2, 3, 8, 4, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
	/// {5, 10, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
	/// {3, 8, 4, 5, 10, 2, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1}, (2, 6, 3)
	{5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
	/// {5, 10, 2, 1, 9, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
	/// {8, 4, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	/// {0, 4, 5, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
	/// {8, 4, 5, 9, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
	///{4, 9, 10, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
	/// {4, 9, 10, 11, 7, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 5, 3)
	{1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
	/// {1, 10, 11, 7, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
	/// {3, 1, 10, 11, 7, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
	/// {4, 9, 1, 2, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
	/// {9, 1, 2, 11, 7, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1}, (2, 6, 3)
	{11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
	/// {11, 7, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
	/// {11, 7, 4, 8, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
	/// {2, 3, 7, 4, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
	/// {9, 10, 2, 0, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
	/// {3, 7, 4, 0, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 7)
	{1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
	/// {4, 9, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
	/// {4, 9, 1, 7, 8, 7, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1}, (2, 4, 4)
	{4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	/// {4, 0, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	/// {9, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
	/// {3, 0, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
	/// {0, 1, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	/// {3, 1, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
	/// {1, 2, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
	/// {3, 0, 9, 1, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	/// {0, 2, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
	/// {2, 3, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 5)
	{9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	/// {9, 10, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
	/// {2, 3, 8, 0, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 6)
	{1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	/// {1, 3, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, (1, 4)
	{0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};
static int NbEquationsToDraw = 1;
static QString ImplicitequationsCollection[30];
static GLuint *IndexPolyTabMin;
static int NbPolyMin;
static double * NormOriginaltmp;
//static double *DataXYZ;
static Voxel *GridVoxelVarPt;
static double *Results;
static int maximumgrid = 60, maxgrscalemaxgr = 3600;
static int SaveThreeTimesNbPolygnTmp=0, SaveSixTimesNbVertexTmp=0, SixTimesNbVertexTmp=0;
static int PreviousSizeMinimalTopology =0;
static int NbPolyMinimalTopology =0;
static int NbVertexTmp = 0;
///+++++++++++++++++++++++++++++++++++++++++
void Iso3D::RunPovScript(){
};

///+++++++++++++++++++++++++++++++++++++++++
void Iso3D::stopcalculations(){
};

///+++++++++++++++++++++++++++++++++++++++++
void Iso3D::SetMinimuMmeshSize(double){
};

///+++++++++++++++++++++++++++++++++++++++++
void Iso3D::SpecialMorph_3(GLfloat *, GLuint *, GLuint *, int *, int *, int){
};
///+++++++++++++++++++++++++++++++++++++++++
/// void Iso3D::SpecialMorph_2(GLfloat *, GLuint *, GLuint *, int *, int *, int, GLuint * a, GLuint *, int){};
///+++++++++++++++++++++++++++++++++++++++++
int Iso3D::setmaxgridto(int maxgrid) {
maximumgrid = maxgrid;
maxgrscalemaxgr = maximumgrid*maximumgrid;
delete GridVoxelVarPt;
delete Results;
//delete DataXYZ;
GridVoxelVarPt = new Voxel[maxgrid*maxgrid*maxgrid];
Results        = new double[maxgrid*maxgrid*maxgrid];
//DataXYZ        = new double[4*maxgrid*maxgrid*maxgrid];
return(1);
};

///+++++++++++++++++++++++++++++++++++++++++
void Iso3D::scalex(int coeff) {
 newscalex = (double)coeff/(double)10; ///(double)(oldcoeff);
 QString after;

 after = "(x/"+QString::number(newscalex)+")";
/// Generate the new Implicit expression...
 if(newscalex != 1) {
ImplicitFunction = ImplicitFunction_save;
ImplicitFunction.replace(QChar('x'), after);
XlimitSup = XlimitSup_save+"*"+QString::number(newscalex);
XlimitInf = XlimitInf_save+"*"+QString::number(newscalex);
YlimitSup = YlimitSup_save;
YlimitInf = YlimitInf_save;
ZlimitSup = ZlimitSup_save;
ZlimitInf = ZlimitInf_save;
}
/// Process the new IsoSurface...
 //ComputeIsoMap();
}

///+++++++++++++++++++++++++++++++++++++++++
void Iso3D::scaley(int coeff) {
 newscaley = (double)coeff/(double)10; ///(double)(oldcoeff);
 QString after;

 after = "(y/"+QString::number(newscaley)+")";
/// Generate the new Implicit expression...
 if(newscaley != 1) {
ImplicitFunction = ImplicitFunction_save;
ImplicitFunction.replace(QChar('y'), after);
YlimitSup = YlimitSup_save+"*"+QString::number(newscaley);
YlimitInf = YlimitInf_save+"*"+QString::number(newscaley);
XlimitSup = XlimitSup_save;
XlimitInf = XlimitInf_save;
ZlimitSup = ZlimitSup_save;
ZlimitInf = ZlimitInf_save;
}
/// Process the new IsoSurface...
 //ComputeIsoMap();
}

///+++++++++++++++++++++++++++++++++++++++++
void Iso3D::scalez(int coeff) {
 newscalez = (double)coeff/(double)10; ///(double)(oldcoeff);
 QString after;

 after = "(z/"+QString::number(newscalez)+")";
/// Generate the new Implicit expression...
 if(newscalez != 1) {
ImplicitFunction = ImplicitFunction_save;
ImplicitFunction.replace(QChar('z'), after);

ZlimitSup = ZlimitSup_save+"*"+QString::number(newscalez);
ZlimitInf = ZlimitInf_save+"*"+QString::number(newscalez);

YlimitSup = YlimitSup_save;
YlimitInf = YlimitInf_save;
XlimitSup = XlimitSup_save;
XlimitInf = XlimitInf_save;
}
/// Process the new IsoSurface...
 //ComputeIsoMap();
}

///+++++++++++++++++++++++++++++++++++++++++
  void Iso3D::twistex(double newtwistex, double newscalex){

 double vals[2]={0,0};
 QString after_1, after_2, angle;
 double tmp;

 if(newtwistex != 0  ||  newscalex !=1) {
angle = "1/("+XlimitSup+"-"+XlimitInf+")";
/// WE EVALUATE THIS PART TO OPTIMASE THE FINAL EQUATION...
ExpressionEvaluator.Parse(angle, "t");
tmp = ExpressionEvaluator.Eval(vals);

tmp *= newtwistex*2*3.14159265/newscalex;
angle = QString::number(tmp)+"*x";

after_1 = "(y*cos("+angle+") - z*sin("+angle+"))";
after_2 = "(y*sin("+angle+") + z*cos("+angle+"))";

ImplicitFunction = ImplicitFunction_save;

ImplicitFunction.replace(QChar('y'), "u");
ImplicitFunction.replace(QChar('z'), "v");
ImplicitFunction.replace(QChar('u'), after_1);
ImplicitFunction.replace(QChar('v'), after_2);
/*
/// We calculate the new cube that contain the distorted object:
///Y :
angle = YlimitSup+"-"+YlimitInf;
ExpressionEvaluator.Parse(angle, "t");
tmp = ExpressionEvaluator.Eval(vals);
tmpy = tmp/2;
///Z:
angle = ZlimitSup+"-"+ZlimitInf;
ExpressionEvaluator.Parse(angle, "t");
tmp = ExpressionEvaluator.Eval(vals);
tmpz = tmp/2;
rayon = sqrt (tmpy*tmpy + tmpz*tmpz);
*/
}
//ComputeIsoMap();
}

///+++++++++++++++++++++++++++++++++++++++++
  void Iso3D::twistey(double newtwistey, double newscaley){
 QString after_1, after_2, angle;
 double tmp;
 double vals[1]={0};

 if(newtwistey != 0) {
angle = "1/("+YlimitSup+"-"+YlimitInf+")";
/// WE EVALUATE THIS PART TO OPTIMASE THE FINAL EQUATION...
ExpressionEvaluator.Parse(angle, "t");
tmp = ExpressionEvaluator.Eval(vals);

angle = QString::number(newtwistey*tmp*2*3.14159265/newscaley)+"*y";
after_1 = "(x*cos("+angle+") - z*sin("+angle+"))";
after_2 = "(x*sin("+angle+") + z*cos("+angle+"))";

ImplicitFunction = ImplicitFunction_save;
ImplicitFunction.replace(QChar('x'), "u");
ImplicitFunction.replace(QChar('z'), "v");
ImplicitFunction.replace(QChar('u'), after_1);
ImplicitFunction.replace(QChar('v'), after_2);

YlimitSup = YlimitSup_save+"*"+QString::number(newscaley);
YlimitInf = YlimitInf_save+"*"+QString::number(newscaley);
}
//ComputeIsoMap();
};

///+++++++++++++++++++++++++++++++++++++++++
  void Iso3D::twistez(double newtwistez, double newscalez){
 QString after_1, after_2, angle;
 double tmp;
 double vals[1]={0};

 if(newtwistez != 0) {
angle = "1/("+ZlimitSup+"-"+ZlimitInf+")";
/// WE EVALUATE THIS PART TO OPTIMASE THE FINAL EQUATION...
ExpressionEvaluator.Parse(angle, "t");
tmp = ExpressionEvaluator.Eval(vals);
angle = QString::number(newtwistez*tmp*2*3.14159265/newscalez)+"*z";
after_1 = "(x*cos("+angle+") - y*sin("+angle+"))";
after_2 = "(x*sin("+angle+") + y*cos("+angle+"))";

ImplicitFunction = ImplicitFunction_save;
ImplicitFunction.replace(QChar('x'), "u");
ImplicitFunction.replace(QChar('y'), "v");
ImplicitFunction.replace(QChar('u'), after_1);
ImplicitFunction.replace(QChar('v'), after_2);
ZlimitSup = ZlimitSup_save+"*"+QString::number(newscalez);
ZlimitInf = ZlimitInf_save+"*"+QString::number(newscalez);
}
//ComputeIsoMap();
};

///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 void Iso3D::PaletteInit(){
 double  coef;
 for(i=0; i<256; i++) {
 coef = (double)i/256;

palette_front_face[i] = QBrush(QColor((int)((double)(frontsurfr)*coef), (int)((double)(frontsurfg)*coef), (int)((double)(frontsurfb)*coef)));

palette_back_face[i] = QBrush(QColor((int)((double)(backsurfr)*coef), (int)((double)(backsurfg)*coef),(int)((double)(backsurfb)*coef)));

palette_CND[i] = QBrush(QColor((int)((double)(CNDsurfr)*coef), (int)((double)(CNDsurfg)*coef),(int)((double)(CNDsurfb)*coef)));

palette_grid[i] = QColor((int)((double)(gridr)*coef), (int)((double)(gridg)*coef),(int)((double)(gridb)*coef));

 if(fronttrans == 1)  palette_front_face[i].setStyle(Qt::HorPattern);
 if(backtrans  == 1)  palette_back_face[i].setStyle(Qt::HorPattern);
 if(CNDtrans   == 1)  palette_CND[i].setStyle(Qt::HorPattern);
 }
}

///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void Iso3D::ChangeMaxResolution(int NewMaximumNumberPoints, int NewMaximumNumberTriangles) {
int * NewWichPointVeryCond;
int * NewWichPointVeryCond2;
int * NewIsoSurfaceTriangleListe;
int * NewIsoSurfaceTriangleListe2;
int * NewTypeIsoSurfaceTriangleListeCND;
int * NewTypeIsoSurfaceTriangleListeCND2;
GLuint  * NewIndexPolyTab;
GLuint  * NewIndexPolyTab2;
GLuint  * NewIndexPolyTabMin;
GLuint  * NewIndexPolyTabMin2;
GLfloat * NewNormVertexTab;
GLfloat * NewNormVertexTab2;
double * NewNormOriginaltmp;
double * NewNormOriginaltmp2;

NewWichPointVeryCond              = new int[NewMaximumNumberPoints];
NewNormVertexTab                  = new GLfloat[6*NewMaximumNumberPoints];

NewIndexPolyTab                   = new GLuint[3*NewMaximumNumberTriangles];
NewIndexPolyTabMin                = new GLuint[3*NewMaximumNumberTriangles];
NewNormOriginaltmp                = new double[3*NewMaximumNumberTriangles];
NewIsoSurfaceTriangleListe        = new int[3*NewMaximumNumberTriangles];
NewTypeIsoSurfaceTriangleListeCND = new int[NewMaximumNumberTriangles];


// Triangles:
if(NewMaximumNumberTriangles > MaximumNumberTriangles){
memcpy(NewTypeIsoSurfaceTriangleListeCND, TypeIsoSurfaceTriangleListeCND, MaximumNumberTriangles*sizeof(int));
memcpy(NewIsoSurfaceTriangleListe, IsoSurfaceTriangleListe, 3*MaximumNumberTriangles*sizeof(int));
memcpy(NewIndexPolyTabMin, IndexPolyTabMin, 3*MaximumNumberTriangles*sizeof(GLuint));
memcpy(NewNormOriginaltmp, NormOriginaltmp, 3*MaximumNumberTriangles*sizeof(double));
memcpy(NewIndexPolyTab, IndexPolyTab, 3*MaximumNumberTriangles*sizeof(GLuint));
}
else{
memcpy(NewTypeIsoSurfaceTriangleListeCND, TypeIsoSurfaceTriangleListeCND, NewMaximumNumberTriangles*sizeof(int));
memcpy(NewIsoSurfaceTriangleListe, IsoSurfaceTriangleListe, 3*NewMaximumNumberTriangles*sizeof(int));
memcpy(NewIndexPolyTabMin, IndexPolyTabMin, 3*NewMaximumNumberTriangles*sizeof(GLuint));
memcpy(NewNormOriginaltmp, NormOriginaltmp, 3*NewMaximumNumberTriangles*sizeof(double));
memcpy(NewIndexPolyTab, IndexPolyTab, 3*NewMaximumNumberTriangles*sizeof(GLuint));
}

// Points:
if(NewMaximumNumberPoints > MaximumNumberPoints) {
memcpy(NewWichPointVeryCond, WichPointVeryCond, MaximumNumberPoints*sizeof(int));
memcpy(NewNormVertexTab, NormVertexTab, 6*MaximumNumberPoints*sizeof(GLfloat));

}
else{
memcpy(NewWichPointVeryCond, WichPointVeryCond, NewMaximumNumberPoints*sizeof(int));
memcpy(NewNormVertexTab, NormVertexTab, 6*NewMaximumNumberPoints*sizeof(GLfloat));

}

NewIsoSurfaceTriangleListe2 = IsoSurfaceTriangleListe;
NewNormVertexTab2 = NormVertexTab;
NewIsoSurfaceTriangleListe2 = IsoSurfaceTriangleListe;
NewIndexPolyTab2 = IndexPolyTab;
NewIndexPolyTabMin2 = IndexPolyTabMin;
NewNormOriginaltmp2 = NormOriginaltmp;
NewWichPointVeryCond2 = WichPointVeryCond;
NewTypeIsoSurfaceTriangleListeCND2 = TypeIsoSurfaceTriangleListeCND;

IsoSurfaceTriangleListe = NewIsoSurfaceTriangleListe;
NormVertexTab           = NewNormVertexTab;
IndexPolyTab            = NewIndexPolyTab;
IndexPolyTabMin         = NewIndexPolyTabMin;
NormOriginaltmp         = NewNormOriginaltmp;
WichPointVeryCond       = NewWichPointVeryCond;
TypeIsoSurfaceTriangleListeCND = NewTypeIsoSurfaceTriangleListeCND;

delete(NewNormVertexTab2);
delete(NewIsoSurfaceTriangleListe2);
delete(NewIndexPolyTab2);
delete(NewIndexPolyTabMin2);
delete (NewNormOriginaltmp2);
delete(NewWichPointVeryCond2);
delete(NewTypeIsoSurfaceTriangleListeCND2);

MaximumNumberPoints    = NewMaximumNumberPoints;
MaximumNumberTriangles = NewMaximumNumberTriangles;
NbPolygonImposedLimit  = 3*MaximumNumberTriangles;
}

///+++++++++++++++++++++++++++++++++++++++++
   Iso3D::Iso3D(){
       static int staticaction = 1;
       Oprime[0]=(double)0.0;
       Oprime[1]=(double)0.0;
       Oprime[2]=(double)800.0;
       D=460;

	   // Calcul Optimisation : Variables definition and initialisation
       UnaryU1 = UnaryU2 = UnaryU3 = "cos(u)";
       BinaryB1= BinaryB2= BinaryB3= "cos(u)*sin(v)";
       U1 = -1; U2 = -1; U3 = -1;
	   B1 = -1; B2 = -1; B3 = -1;
       DataTable[0]  = XLocal;
       DataTable[1]  = YLocal;
       DataTable[2]  = ZLocal;

       DataTable[13] = Dxy;
       DataTable[14] = Dxz;
       DataTable[15] = Dyz;
       DataTable[16] = Dyx;
       DataTable[17] = Dzx;
       DataTable[18] = Dzy;

       DataTable[19] = Exy;
       DataTable[20] = Exz;
       DataTable[21] = Eyz;
       DataTable[22] = Eyx;
       DataTable[23] = Ezx;
       DataTable[24] = Ezy;

       DataTable[25] = Fxy;
       DataTable[26] = Fxz;
       DataTable[27] = Fyz;
       DataTable[28] = Fyx;
       DataTable[29] = Fzx;
       DataTable[30] = Fzy;

       MaximumNumberPoints    = 100000;
       MaximumNumberTriangles = 200000;

       WichPointVeryCond = new int[MaximumNumberPoints];
       IndexPolyTab      = new GLuint[3*MaximumNumberTriangles];
       IndexPolyTabMin   = new GLuint[3*MaximumNumberTriangles];

       TypeIsoSurfaceTriangleListeCND = new int[MaximumNumberTriangles];
       IsoSurfaceTriangleListe        = new int[3*MaximumNumberTriangles];
       NormVertexTab                  = new GLfloat[6*MaximumNumberPoints];
       NormOriginaltmp                = new double[3*MaximumNumberTriangles];

       /// Things to do one times...
       if(staticaction == 1) {
           GridVoxelVarPt  = new  Voxel[60*60*60];
           Results         = new double[60*60*60];
           staticaction *= -1;
       }

       MatGen.unit();
       MatRot.unit();
       MatRotSave.unit();

       NbPointIsoMap = 0;
       NbTriangleIsoSurface = 0;

       morph_param = 1;
       step = 0.05;

       ImplicitFunction = ImplicitFunction_save = "cos(x) + cos(y) + cos(z)";
       IsoCondition = "(x^2 + y^2 > 0.05) & ( x+y+z > -1)";

       IsoConditionRequired  = -1;
       XlimitSup = XlimitSup_save = "4";
       YlimitSup = YlimitSup_save = "4";
       ZlimitSup = ZlimitSup_save = "4";
       XlimitInf = XlimitInf_save = "-4";
       YlimitInf = YlimitInf_save = "-4";
       ZlimitInf = ZlimitInf_save = "-4";

       X_Start = 4; X_End = -4;
       Y_Start = 4; Y_End = -4;
       Z_Start = 4; Z_End = -4;

       nb_ligne = nb_colon = nb_depth = 26;
       IsoValue = 0;

       backsurfr = 249;
       backsurfg = 170;
       backsurfb = 0;

       frontsurfr = 0;
       frontsurfg = 210;
       frontsurfb = 0;

       CNDsurfr = 210;
       CNDsurfg = 0;
       CNDsurfb = 0;

       fronttrans = backtrans = CNDtrans = -1;

       NbPolygonImposedLimit = 500000;
       DrawAxe_Ok = -1;
       ActivateHeightSpeedCalculations = -1;
       gridr = 0;
       gridg = 100;
       gridb = 4;
       gridtransparent = 1;
       IsoMesh = -1;
       IsoInfos = 1; /// To show infos
       Borderlimite = 0;

       CNDMesh = 1; CNDDraw = 1; BorderDraw = 1;

       axe_width  = 2;
       axe_size   = 1;
       axe_center = 1;

       PovActivate = -1; /// To save the shape for the output file
       hauteur_fenetre = 650;
       demi_hauteur = demi_largeur = hauteur_fenetre/2;

       ImplicitFunctionParser.AddConstant ("pi", 3.14159265);
       for (int i=0; i < maxgrscalemaxgr; i++)
       tableaureferences[i] = new QPointArray(3);

       tableau = new IsoTriangle[maxgrscalemaxgr];

       InitParser();
       ParseExpression();
       PaletteInit();
   };
///+++++++++++++++++++++++++++++++++++++++++
int Iso3D::Parse(QString IsoFormulas){
int i, position, retour;
QString string;
NbEquationsToDraw = IsoFormulas.contains( ':', FALSE );
if(NbEquationsToDraw < 2) {
NbEquationsToDraw=1;
IsoFormulas = IsoFormulas.remove(":");
return (
ImplicitFunctionParser.Parse(IsoFormulas,
"x,y,z,t,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dxy,Dxz,Dyz,Dyx,Dzx,Dzy,Exy,Exz,Eyz,Eyx,Ezx,Ezy,Fxy,Fxz,Fyz,Fyx,Fzx,Fzy")
);
}
else{

string = IsoFormulas;
for(i = 0; i<NbEquationsToDraw ; i++){
position = string.find(":");
ImplicitequationsCollection[i] = string.mid(0, position);
string.remove(0, position+1);
retour = ImplicitFunctionParser.Parse(ImplicitequationsCollection[i],
"x,y,z,t,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dxy,Dxz,Dyz,Dyx,Dzx,Dzy,Exy,Exz,Eyz,Eyx,Ezx,Ezy,Fxy,Fxz,Fyz,Fyx,Fzx,Fzy");
if(retour > 0) return(retour);
}
return(-1);
}

};

///+++++++++++++++++++++++++++++++++++++++++
  void Iso3D::ParseExpression() {
      double vals[] = {0, 0, 0, 0, 0, 0, 0};
ImplicitFunctionParser.Parse(ImplicitFunction,
"x,y,z,t,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dxy,Dxz,Dyz,Dyx,Dzx,Dzy,Exy,Exz,Eyz,Eyx,Ezx,Ezy,Fxy,Fxz,Fyz,Fyx,Fzx,Fzy");

       IsoConditionParser.Parse(IsoCondition, "x,y,z,t");

       XSupParser.Parse(XlimitSup, "x,y,z,t");
       X_Start = XSupParser.Eval(vals);

       YSupParser.Parse(YlimitSup, "x,y,z,t");
       Y_Start = YSupParser.Eval(vals);

       ZSupParser.Parse(ZlimitSup, "x,y,z,t");
       Z_Start = ZSupParser.Eval(vals);

       XInfParser.Parse(XlimitInf, "x,y,z,t");
       X_End = XInfParser.Eval(vals);

       YInfParser.Parse(YlimitInf, "x,y,z,t");
       Y_End = YInfParser.Eval(vals);

       ZInfParser.Parse(ZlimitInf, "x,y,z,t");
       Z_End = ZInfParser.Eval(vals);
 };

///+++++++++++++++++++++++++++++++++++++++++
   void Iso3D::InitParser(){

       ImplicitFunctionParser.AddConstant("pi", 3.14159265);
       IsoConditionParser.AddConstant("pi", 3.14159265);
       XSupParser.AddConstant("pi", 3.14159265);
       YSupParser.AddConstant("pi", 3.14159265);
       ZSupParser.AddConstant("pi", 3.14159265);
       XInfParser.AddConstant("pi", 3.14159265);
       YInfParser.AddConstant("pi", 3.14159265);
       ZInfParser.AddConstant("pi", 3.14159265);
       ExpressionEvaluator.AddConstant("pi", 3.14159265);
   };
///+++++++++++++++++++++++++++++++++++++++++
   void Iso3D::VoxelEvaluation (){
   double vals[] = {0,0,0,0,0,0,0};
   const int limitX = nb_ligne, limitY = nb_colon, limitZ = nb_depth;
   int MaxGR = maximumgrid;
   FunctionParser ImplicitFunctionParser1 = ImplicitFunctionParser,
   ImplicitFunctionParser2 = ImplicitFunctionParser,
   ImplicitFunctionParser3 = ImplicitFunctionParser;
   double dxy[2];

/// this is for the morph effect...
if(morph_param >= 0.0)  vals[3] = morph_param;
else  vals[3] = -morph_param;
morph_param += step;
if( morph_param == 1) morph_param = 0;

//Can be optimised by considering Three array of 30 values each
// Each array contain the 30 value of one axe...
     X_Step = (X_Start - X_End)/(limitX-1);
     Y_Step = (Y_Start - Y_End)/(limitY-1);
     Z_Step = (Z_Start - Z_End)/(limitZ-1);
     XLocal[0]=X_Start;
     YLocal[0]=Y_Start;
     ZLocal[0]=Z_Start;
for (i= 1; i < limitX; i++) XLocal[i] = XLocal[i-1] - X_Step;
for (j= 1; j < limitY; j++) YLocal[j] = YLocal[j-1] - Y_Step;
for (k= 1; k < limitZ; k++) ZLocal[k] = ZLocal[k-1] - Z_Step;

if((limitZ % 4) != 0 || ActivateHeightSpeedCalculations == -1) {
     for(i=0; i<limitX; i++) {
         vals[0] = XLocal[i];
             I = i*maxgrscalemaxgr;
      for(j=0; j<limitY; j++) {
         vals[1] = YLocal[j];
             J = I + j*maximumgrid;
       for(k=0; k<limitZ; k++) {
         vals[2] = ZLocal[k];
             IJK = J+k;
//for( nbtimes =0; nbtimes <100; nbtimes++)
        Results[IJK]= ImplicitFunctionParser.Eval(vals);
        GridVoxelVarPt[IJK].Signature   = 0; // Signature initialisation
        GridVoxelVarPt[IJK].NbEdgePoint = 0; // No EdgePoint yet!
for(l=0; l<12; l++) GridVoxelVarPt[IJK].Edge_Points[l] = -20; /// just for verification
                               }}}
}
else {
       for(i=0; i<limitX; i++) {
           I = i*maxgrscalemaxgr;
       for(j=0; j<limitY; j++) {
           J = I + j*maximumgrid;
       for(k=0; k<limitZ; k++) {
           IJK = J+k;
         GridVoxelVarPt[IJK].Signature   = 0; // Signature initialisation
         GridVoxelVarPt[IJK].NbEdgePoint = 0; // No EdgePoint yet!
         for(l=0; l<12; l++) GridVoxelVarPt[IJK].Edge_Points[l] = -20;
 }}}

// Data preparation for use by the parser:
 for(i =0; i<31; i++) DataActive[i] = -1;

/// For some reason, using u1 parser make the prog crash!!!
//A[u]
if(U1 == 1){
b1.Parse(UnaryU1,"u");
if(ImplicitFunction.contains("Ax")){
for(i=0; i<limitX; i++) XLocal[i+limitX] = b1.Eval(&XLocal[i]);
DataActive[4] = 1;
}
if(ImplicitFunction.contains("Ay")){
for(i=0; i<limitY; i++) YLocal[i+limitY] = b1.Eval(&YLocal[i]);
DataActive[5] = 1;
}
if(ImplicitFunction.contains("Az")){
for(i=0; i<limitZ; i++) ZLocal[i+limitZ] = b1.Eval(&ZLocal[i]);
DataActive[6] = 1;
}
}

//B[u]
if(U2 == 1){
b2.Parse(UnaryU2,"u");
if(ImplicitFunction.contains("Bx")){
for(i=0; i<limitX; i++) XLocal[i+limitX+limitZ] = b2.Eval(&XLocal[i]);
DataActive[7] = 1;
}
if(ImplicitFunction.contains("By")){
for(i=0; i<limitY; i++) YLocal[i+limitY+limitZ] = b2.Eval(&YLocal[i]);
DataActive[8] = 1;
}
if(ImplicitFunction.contains("Bz")){
for(i=0; i<limitZ; i++) ZLocal[i+limitZ+limitZ] = b2.Eval(&ZLocal[i]);
DataActive[9] = 1;
}
}

//C[u]
if(U3 == 1){
b3.Parse(UnaryU3,"u");
if(ImplicitFunction.contains("Cx")){
for(i=0; i<limitX; i++) XLocal[i+limitX+2*limitZ] = b3.Eval(&XLocal[i]);
DataActive[10] = 1;
}
if(ImplicitFunction.contains("Cy")){
for(i=0; i<limitY; i++) YLocal[i+limitY+2*limitZ] = b3.Eval(&YLocal[i]);
DataActive[11] = 1;
}
if(ImplicitFunction.contains("Cz")){
for(i=0; i<limitZ; i++) ZLocal[i+limitZ+2*limitZ] = b3.Eval(&ZLocal[i]);
DataActive[12] = 1;
}
}

//+++++++++++D[u,v]+++++++++++
if(B1 == 1){
b1.Parse(BinaryB1,"u,v");
//Dxy
if(ImplicitFunction.contains("Dxy")){
for(i=0; i<limitX; i++)
  for(j=0; j<limitY; j++){
  dxy[0] = XLocal[i];
  dxy[1] = YLocal[j];
  Dxy[i*limitX+j] = b1.Eval(dxy);
  }
DataActive[13] = 1;
}
//Dyx
if(ImplicitFunction.contains("Dyx")){
for(i=0; i<limitX; i++)
  for(j=0; j<limitY; j++){
  dxy[1] = XLocal[i];
  dxy[0] = YLocal[j];
  Dyx[i*limitX+j] = b1.Eval(dxy);
  }
DataActive[16] = 1;
}
//Dxz
if(ImplicitFunction.contains("Dxz")){
for(i=0; i<limitX; i++)
  for(k=0; k<limitZ; k++){
  dxy[0] = XLocal[i];
  dxy[1] = ZLocal[k];
  Dxz[i*limitX+k] = b1.Eval(dxy);
  }
DataActive[14] = 1;
}
//Dzx
if(ImplicitFunction.contains("Dzx")){
for(i=0; i<limitX; i++)
  for(k=0; k<limitZ; k++){
  dxy[1] = XLocal[i];
  dxy[0] = ZLocal[k];
  Dzx[i*limitX+k] = b1.Eval(dxy);
  }
DataActive[17] = 1;
}
//Dyz
if(ImplicitFunction.contains("Dyz")){
for(j=0; j<limitY; j++)
  for(k=0; k<limitZ; k++){
  dxy[0] = YLocal[j];
  dxy[1] = ZLocal[k];
  Dyz[j*limitY+k] = b1.Eval(dxy);
  }
DataActive[15] = 1;
}
//Dzy
if(ImplicitFunction.contains("Dzy")){
for(j=0; j<limitY; j++)
  for(k=0; k<limitZ; k++){
  dxy[1] = YLocal[j];
  dxy[0] = ZLocal[k];
  Dzy[j*limitY+k] = b1.Eval(dxy);
  }
DataActive[18] = 1;
}
}

//+++++++++++++++E[u,v]++++++++++++++++
if(B2 == 1){
b2.Parse(BinaryB2,"u,v");
//Exy
if(ImplicitFunction.contains("Exy")){
for(i=0; i<limitX; i++)
  for(j=0; j<limitY; j++){
  Exy[0] = XLocal[i];
  Exy[1] = YLocal[j];
  Exy[i*limitX+j] = b2.Eval(Exy);
  }
DataActive[19] = 1;
}
//Eyx
if(ImplicitFunction.contains("Eyx")){
for(i=0; i<limitX; i++)
  for(j=0; j<limitY; j++){
  Exy[1] = XLocal[i];
  Exy[0] = YLocal[j];
  Eyx[i*limitX+j] = b2.Eval(Exy);
  }
DataActive[22] = 1;
}
//Exz
if(ImplicitFunction.contains("Exz")){
for(i=0; i<limitX; i++)
  for(k=0; k<limitZ; k++){
  Exy[0] = XLocal[i];
  Exy[1] = ZLocal[k];
  Exz[i*limitX+k] = b2.Eval(Exy);
  }
DataActive[20] = 1;
}
//Ezx
if(ImplicitFunction.contains("Ezx")){
for(i=0; i<limitX; i++)
  for(k=0; k<limitZ; k++){
  Exy[1] = XLocal[i];
  Exy[0] = ZLocal[k];
  Ezx[i*limitX+k] = b2.Eval(Exy);
  }
DataActive[23] = 1;
}
//Eyz
if(ImplicitFunction.contains("Eyz")){
for(j=0; j<limitY; j++)
  for(k=0; k<limitZ; k++){
  Exy[0] = YLocal[j];
  Exy[1] = ZLocal[k];
  Eyz[j*limitY+k] = b2.Eval(Exy);
  }
DataActive[21] = 1;
}
//Ezy
if(ImplicitFunction.contains("Ezy")){
for(j=0; j<limitY; j++)
  for(k=0; k<limitZ; k++){
  Exy[1] = YLocal[j];
  Exy[0] = ZLocal[k];
  Ezy[j*limitY+k] = b2.Eval(Exy);
  }
DataActive[24] = 1;
}
}

//++++++++++++++F[u,v]++++++++++++++
if(B3 == 1){
b3.Parse(BinaryB3,"u,v");
//Fxy
if(ImplicitFunction.contains("Fxy")){
for(i=0; i<limitX; i++)
  for(j=0; j<limitY; j++){
  Fxy[0] = XLocal[i];
  Fxy[1] = YLocal[j];
  Fxy[i*limitX+j] = b3.Eval(Fxy);
  }
DataActive[25] = 1;
}
//Fyx
if(ImplicitFunction.contains("Fyx")){
for(i=0; i<limitX; i++)
  for(j=0; j<limitY; j++){
  Fxy[1] = XLocal[i];
  Fxy[0] = YLocal[j];
  Fyx[i*limitX+j] = b3.Eval(Fxy);
  }
DataActive[28] = 1;
}
//Fxz
if(ImplicitFunction.contains("Fxz")){
for(i=0; i<limitX; i++)
  for(k=0; k<limitZ; k++){
  Fxy[0] = XLocal[i];
  Fxy[1] = ZLocal[k];
  Fxz[i*limitX+k] = b3.Eval(Fxy);
  }
DataActive[26] = 1;
}
//Fzx
if(ImplicitFunction.contains("Fzx")){
for(i=0; i<limitX; i++)
  for(k=0; k<limitZ; k++){
  Fxy[1] = XLocal[i];
  Fxy[0] = ZLocal[k];
  Fzx[i*limitX+k] = b3.Eval(Fxy);
  }
DataActive[29] = 1;
}
//Fyz
if(ImplicitFunction.contains("Fyz")){
for(j=0; j<limitY; j++)
  for(k=0; k<limitZ; k++){
  Fxy[0] = YLocal[j];
  Fxy[1] = ZLocal[k];
  Fyz[j*limitY+k] = b3.Eval(Fxy);
  }
DataActive[27] = 1;
}
//Fzy
if(ImplicitFunction.contains("Fzy")){
for(j=0; j<limitY; j++)
  for(k=0; k<limitZ; k++){
  Fxy[1] = YLocal[j];
  Fxy[0] = ZLocal[k];
  Fzy[j*limitY+k] = b3.Eval(Fxy);
  }
DataActive[30] = 1;
}
}



/*
if( ImplicitFunction.contains("U1X") !=0){
U1.Parse(UnaryU1,"u");alreadyparsed = 1;
for(i=0; i<limitX; i++) XLocal[i+limitX] = U1.Eval(&XLocal[i]);
}
if( ImplicitFunction.contains("U1Y") !=0){
if(alreadyparsed != 1) U1.Parse(UnaryU1,"u");
for(i=0; i<limitY; i++) YLocal[i+limitY] = U1.Eval(&YLocal[i]);
}
if( ImplicitFunction.contains("U1Z") !=0){
if(alreadyparsed != 1) U1.Parse(UnaryU1,"u");
for(i=0; i<limitZ; i++) ZLocal[i+limitZ] = U1.Eval(&ZLocal[i]);
}
*/
ImplicitFunctionParser.AllocateMemoryForStackArray(XLocal,YLocal,ZLocal,Dxy,Dxz,Dyz,XLocal,YLocal,ZLocal,vals[3],MaxGR,Results,limitZ,DataActive, DataTable);
ImplicitFunctionParser.Eval6();
 //ImplicitFunctionParser.Eval6();
 //ImplicitFunctionParser.start();
 //ImplicitFunctionParser1.start();
 //ImplicitFunctionParser.wait();
 //ImplicitFunctionParser1.wait();
/*
     for(i=0; i<limitX; i++) {
         x = XLocal[i];
         I = i*maxgrscalemaxgr;
      for(j=0; j<limitY; j++) {
         y = YLocal[j];
         J = I + j*maximumgrid;
       for(k=0; k<limitZ; k++) {
         z            = ZLocal[k];
         IJK          = J+k;
         Results[IJK] = cos(x) + cos(y) + cos(z) + 0.00001*cos(x*z) - 0.00001*cos(x) - 0.00001*cos(y)*( cos(x) +0.00001*cos(y*x*( cos(x) +cos(y*x) + cos(z*y))) + 0.00001*cos(y)) + 0.00001*sin(z-y)*( sin(x+z) +0.00001*cos(y*x*( sin(x*z) +cos(y*x) + cos(z))) + cos(y)) - 0.00001*sin(z*y*cos(x))*( sin(x) +cos(y*x*( sin(z) +cos(x) + cos(z*y))) + 0.00001*cos(y)) *cos(y*x*( sin(z) +cos(y*x) + cos(y)))*x*y + 0.00001*cos(y) + 0.00001*cos(x) + 0.00001*cos(y) + 0.00001*cos(z) + 0.00001*cos(z) - 0.00001*cos(y*x) - 0.00001*cos(y)*( cos(x*z) +cos(y*x*( cos(z) +cos(y) + cos(z*y))) + 0.00001*cos(y)) + 0.00001*sin(z-y)*( sin(x) +cos(y*x*( sin(z) +cos(y-x) + cos(z-y))) + 0.00001*cos(z*y)) - 0.00001*sin(z*y*cos(x))*( sin(x) +cos(y*x*( sin(x*z) +cos(x) + cos(z))) + 0.00001*cos(y)) *cos(y*x*( sin(z) +cos(x) + cos(z*y)))*x*y + 0.00001*cos(z*y)   ;
  }}}
*/
/*
ImplicitFunctionParser2.start();
ImplicitFunctionParser2.wait();
ImplicitFunctionParser3.start();
ImplicitFunctionParser3.wait();
*/
}
};

///+++++++++++++++++++++++++++++++++++++++++
  void Iso3D::ComputeIsoMap() {
       ParseExpression();
       VoxelEvaluation ();
       PointEdgeComputation();
       SignatureComputation();
       //BoxIsoMap();
       ConstructIsoSurface();
       ConstructIsoNormale();
       BoxIsoMap();
       ApplicateTransform(); /// On applique la matrice principale
}

///+++++++++++++++++++++++++++++++++++++++++
   void Iso3D::AnimMorph(){
       ///ParseExpression();
       VoxelEvaluation ();
       PointEdgeComputation();
       SignatureComputation();
       //BoxIsoMap();
       ConstructIsoSurface();
       ConstructIsoNormale();BoxIsoMap();
       Rotate();
       ApplicateTransform(); /// On applique la matrice principal
};
///++++++++++++++++++++++++++++++++++++++++
   void Iso3D::CutIsoSurface(){
       ConstructIsoSurface();
       ConstructIsoNormale();
       ApplicateTransform(); /// On applique la matrice principal
};
///+++++++++++++++++++++++++++++++++++++++++
   void Iso3D::ConstructIsoNormale(){
double val1, val2, val3, val4, val5, val6,
       pt1_x, pt1_y, pt1_z,
       pt2_x, pt2_y, pt2_z,
       pt3_x, pt3_y, pt3_z,
       scalar;
int ThreeTimesI, IndexFirstPoint, IndexSecondPoint, IndexThirdPoint;
/*
for(i = 0; i<NbTriangleIsoSurface; ++i) {

 ThreeTimesI   = i*3;

IndexFirstPoint  = 3*IsoSurfaceTriangleListe[ThreeTimesI  ];
IndexSecondPoint = 3*IsoSurfaceTriangleListe[ThreeTimesI+1];
IndexThirdPoint  = 3*IsoSurfaceTriangleListe[ThreeTimesI+2];


 pt1_x= IsoPointMapOriginal[IndexFirstPoint  ];
 pt1_y= IsoPointMapOriginal[IndexFirstPoint+1];
 pt1_z= IsoPointMapOriginal[IndexFirstPoint+2];

 pt2_x= IsoPointMapOriginal[IndexSecondPoint  ];
 pt2_y= IsoPointMapOriginal[IndexSecondPoint+1];
 pt2_z= IsoPointMapOriginal[IndexSecondPoint+2];

 pt3_x= IsoPointMapOriginal[IndexThirdPoint  ];
 pt3_y= IsoPointMapOriginal[IndexThirdPoint+1];
 pt3_z= IsoPointMapOriginal[IndexThirdPoint+2];

val1 = pt2_y - pt1_y;
val2 = pt3_z - pt1_z;
val3 = pt2_z - pt1_z;
val4 = pt3_y - pt1_y;
val5 = pt3_x - pt1_x;
val6 = pt2_x - pt1_x;

NormOriginal[ThreeTimesI  ] = val1*val2 - val3*val4;
NormOriginal[ThreeTimesI+1] = val3*val5 - val6*val2;
NormOriginal[ThreeTimesI+2] = val6*val4 - val1*val5;

scalar = (double)sqrt((NormOriginal[ThreeTimesI  ]*NormOriginal[ThreeTimesI  ]) +
                      (NormOriginal[ThreeTimesI+1]*NormOriginal[ThreeTimesI+1]) +
                      (NormOriginal[ThreeTimesI+2]*NormOriginal[ThreeTimesI+2]));

if(scalar < 0.000000001)  scalar  = 0.000000001;
(NormOriginal[ThreeTimesI  ]/=scalar);
(NormOriginal[ThreeTimesI+1]/=scalar);
(NormOriginal[ThreeTimesI+2]/=scalar);
}
*/

for(i = 0; i<NbTriangleIsoSurface; ++i) {

ThreeTimesI   = i*3;

IndexFirstPoint  = 2*3*IsoSurfaceTriangleListe[ThreeTimesI  ]+SixTimesNbVertexTmp+3;
IndexSecondPoint = 2*3*IsoSurfaceTriangleListe[ThreeTimesI+1]+SixTimesNbVertexTmp+3;
IndexThirdPoint  = 2*3*IsoSurfaceTriangleListe[ThreeTimesI+2]+SixTimesNbVertexTmp+3;

 pt1_x= NormVertexTab[IndexFirstPoint  ];
 pt1_y= NormVertexTab[IndexFirstPoint+1];
 pt1_z= NormVertexTab[IndexFirstPoint+2];

 pt2_x= NormVertexTab[IndexSecondPoint  ];
 pt2_y= NormVertexTab[IndexSecondPoint+1];
 pt2_z= NormVertexTab[IndexSecondPoint+2];

 pt3_x= NormVertexTab[IndexThirdPoint  ];
 pt3_y= NormVertexTab[IndexThirdPoint+1];
 pt3_z= NormVertexTab[IndexThirdPoint+2];

val1 = pt2_y - pt1_y;
val2 = pt3_z - pt1_z;
val3 = pt2_z - pt1_z;
val4 = pt3_y - pt1_y;
val5 = pt3_x - pt1_x;
val6 = pt2_x - pt1_x;

NormOriginaltmp[ThreeTimesI  ] = val1*val2 - val3*val4;
NormOriginaltmp[ThreeTimesI+1] = val3*val5 - val6*val2;
NormOriginaltmp[ThreeTimesI+2] = val6*val4 - val1*val5;

scalar = (double)sqrt((NormOriginaltmp[ThreeTimesI  ]*NormOriginaltmp[ThreeTimesI  ]) +
                      (NormOriginaltmp[ThreeTimesI+1]*NormOriginaltmp[ThreeTimesI+1]) +
                      (NormOriginaltmp[ThreeTimesI+2]*NormOriginaltmp[ThreeTimesI+2]));

if(scalar < 0.000000001)  scalar  = 0.000000001;
(NormOriginaltmp[ThreeTimesI  ]/=scalar);
(NormOriginaltmp[ThreeTimesI+1]/=scalar);
(NormOriginaltmp[ThreeTimesI+2]/=scalar);
}

};
//NormVertexTab[l  +SixTimesNbVertexTmp]
///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++///
///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++///
   void Iso3D::BoxIsoMap(){
int ThreeTimesI;

MINX = 999999999;
MINY = 999999999;
MINZ = 999999999;

MAXX =-999999999;
MAXY =-999999999;
MAXZ =-999999999;

 for (i=0; i < NbPointIsoMap   ; i++){
 ThreeTimesI = 3*i;
          if(MINX > IsoPointMapOriginal[ThreeTimesI  ] ) MINX = IsoPointMapOriginal[ThreeTimesI  ] ;

     else if(MINY > IsoPointMapOriginal[ThreeTimesI+1] ) MINY = IsoPointMapOriginal[ThreeTimesI+1] ;

     else if(MINZ > IsoPointMapOriginal[ThreeTimesI+2] ) MINZ = IsoPointMapOriginal[ThreeTimesI+2] ;

     else if(MAXX < IsoPointMapOriginal[ThreeTimesI  ] ) MAXX = IsoPointMapOriginal[ThreeTimesI  ] ;

     else if(MAXY < IsoPointMapOriginal[ThreeTimesI+1] ) MAXY = IsoPointMapOriginal[ThreeTimesI+1] ;

     else if(MAXZ < IsoPointMapOriginal[ThreeTimesI+2] ) MAXZ = IsoPointMapOriginal[ThreeTimesI+2] ;
                                  }

  DIFX = MAXX - MINX ;
  DIFY = MAXY - MINY ;
  DIFZ = MAXZ - MINZ ;
// Recherche du maximum :
  DIFMAXIMUM = DIFX;
  if (DIFY > DIFMAXIMUM) {DIFMAXIMUM = DIFY;};
  if (DIFZ > DIFMAXIMUM) {DIFMAXIMUM = DIFZ;};

/// On va inclure cet objet dans un cube de langueur maximum
/// egale a "hauteur_fenetre"

double decalage_xo = -(MINX +MAXX)/2 ;
double decalage_yo = -(MINY +MAXY)/2 ;
double decalage_zo = -(MINZ +MAXZ)/2 ;

 for (i=0; i < NbPointIsoMap ; i++) {
 ThreeTimesI = 3*i;
IsoPointMapOriginal[ThreeTimesI  ] = hauteur_fenetre*(IsoPointMapOriginal[ThreeTimesI  ] + decalage_xo)/DIFMAXIMUM ;

IsoPointMapOriginal[ThreeTimesI+1] = hauteur_fenetre*(IsoPointMapOriginal[ThreeTimesI+1] + decalage_yo)/DIFMAXIMUM ;

IsoPointMapOriginal[ThreeTimesI+2] = hauteur_fenetre*(IsoPointMapOriginal[ThreeTimesI+2] + decalage_zo)/DIFMAXIMUM ;
}
 /// End of if(DrawAxe_Ok == 1)...
};


///++++++++++++++++++++ OutPut The IsoSurface +++++++++++++++++++++++

   void Iso3D::SaveIsoGLMap() {
     int IndexFirstPoint, IndexSecondPoint, IndexThirdPoint, ThreeTimesI;
     double scalar;


/// Recalculate the normals so we have one for each Point (like for Pov Mesh) :
   for (i=0; i < NbPointIsoMap ; i++){
        ThreeTimesI = 6*i;
        NormVertexTab[SixTimesNbVertexTmp+ThreeTimesI  ] = 0;
        NormVertexTab[SixTimesNbVertexTmp+ThreeTimesI+1] = 0;
        NormVertexTab[SixTimesNbVertexTmp+ThreeTimesI+2] = 0;
}

for(i = 0; i<NbTriangleIsoSurface; ++i) {
ThreeTimesI   = i*3;

IndexFirstPoint  = 2*3*IsoSurfaceTriangleListe[ThreeTimesI  ]+SixTimesNbVertexTmp;
IndexSecondPoint = 2*3*IsoSurfaceTriangleListe[ThreeTimesI+1]+SixTimesNbVertexTmp;
IndexThirdPoint  = 2*3*IsoSurfaceTriangleListe[ThreeTimesI+2]+SixTimesNbVertexTmp;

NormVertexTab[IndexFirstPoint  ] += NormOriginaltmp[ThreeTimesI  ];
NormVertexTab[IndexFirstPoint+1] += NormOriginaltmp[ThreeTimesI+1];
NormVertexTab[IndexFirstPoint+2] += NormOriginaltmp[ThreeTimesI+2];

NormVertexTab[IndexSecondPoint  ] += NormOriginaltmp[ThreeTimesI  ];
NormVertexTab[IndexSecondPoint+1] += NormOriginaltmp[ThreeTimesI+1];
NormVertexTab[IndexSecondPoint+2] += NormOriginaltmp[ThreeTimesI+2];

NormVertexTab[IndexThirdPoint  ] += NormOriginaltmp[ThreeTimesI  ];
NormVertexTab[IndexThirdPoint+1] += NormOriginaltmp[ThreeTimesI+1];
NormVertexTab[IndexThirdPoint+2] += NormOriginaltmp[ThreeTimesI+2];
}

/// Normalisation of theses resulting normales
if(NbEquationsToDraw ==1)
 for (i=0; i < NbPointIsoMap  ; i++){
 ThreeTimesI = 6*i;
scalar = (double)sqrt((NormVertexTab[ThreeTimesI  ]*NormVertexTab[ThreeTimesI  ]) +
                      (NormVertexTab[ThreeTimesI+1]*NormVertexTab[ThreeTimesI+1]) +
                      (NormVertexTab[ThreeTimesI+2]*NormVertexTab[ThreeTimesI+2]));
if(scalar < 0.000000001)  scalar  = 0.000000001;
NormVertexTab[ThreeTimesI  ] /= scalar;
NormVertexTab[ThreeTimesI+1] /= scalar;
NormVertexTab[ThreeTimesI+2] /= scalar;
}

}

///++++++++++++++++++++  ++++++++++++++++++++++

  void Iso3D::SpecialMorph_2(GLfloat *NormVertexTabPt, GLuint *IndexPolyTabPt, GLuint *NbPolygnNbVertexPt, int *TypeIsoSurfaceTriangleListeCNDPt, int *VertexNumberpt, int NbStep, GLuint *IndexPolyTabMinPt, int *NbPolyMinPt, int) {
    int TmpImplicitEquation, TmpMorphStep=0,
ThreeTimesNbPolygnTmp=0, ThreeTimesI, l, drawaxe_ok=0;
    double step_local, scalar;

PreviousSizeMinimalTopology =0;
NbPolyMinimalTopology =0;

NbVertexTmp = SaveThreeTimesNbPolygnTmp = SaveSixTimesNbVertexTmp = SixTimesNbVertexTmp=0;

if(NbEquationsToDraw ==1) {

if(DrawAxe_Ok == 1) {drawaxe_ok = 1; DrawAxe_Ok = -1;};

morph_param = 0.0; // The starting point of the morph effect.
step_local = step; // To save this value
step = 1.0/(double)NbStep;

for(TmpMorphStep=0; TmpMorphStep<NbStep; TmpMorphStep++) {
       CurrentStep = TmpMorphStep; // To store infos NbPointIsoMap and NbTriangleIsoSurface
       ParseExpression();
       VoxelEvaluation ();
       PointEdgeComputation();
       SignatureComputation();
       ConstructIsoSurface();
       ConstructIsoNormale();
       SaveIsoGLMap();
       SetMiniMmeshStructStream("", 3);
/// Save results :
// Save the Starting of the first Triangles for this specific Morph Step :
// Save the Index:
l = 0;
for ( i=0; i < NbTriangleIsoSurface ; ++i) {
ThreeTimesI = 3*i;
IndexPolyTab[l  + ThreeTimesNbPolygnTmp] = IsoSurfaceTriangleListe[ThreeTimesI  ] + NbVertexTmp;
IndexPolyTab[l+1+ ThreeTimesNbPolygnTmp] = IsoSurfaceTriangleListe[ThreeTimesI+1] + NbVertexTmp;
IndexPolyTab[l+2+ ThreeTimesNbPolygnTmp] = IsoSurfaceTriangleListe[ThreeTimesI+2] + NbVertexTmp;
l+=3;
}

// Save Number of Polys and vertex :
NbPolygnNbVertex[2*CurrentStep  ] = 3*NbTriangleIsoSurface;
NbPolygnNbVertex[2*CurrentStep+1] = ThreeTimesNbPolygnTmp;//ThreeTimesNbPolygnTmp;

NbVertexTmp           += NbPointIsoMap;
SixTimesNbVertexTmp    = 6*NbVertexTmp;
ThreeTimesNbPolygnTmp += 3*NbTriangleIsoSurface;
}

/// Put the object Inside a Cube :
MINX = 999999999;
MINY = 999999999;
MINZ = 999999999;

MAXX =-999999999;
MAXY =-999999999;
MAXZ =-999999999;
 for (i=0; i < NbVertexTmp; i++){
 ThreeTimesI = 2*3*i;
          if(MINX > NormVertexTab[3+ThreeTimesI  ] ) MINX = NormVertexTab[3+ThreeTimesI  ] ;
     else if(MINY > NormVertexTab[3+ThreeTimesI+1] ) MINY = NormVertexTab[3+ThreeTimesI+1] ;
     else if(MINZ > NormVertexTab[3+ThreeTimesI+2] ) MINZ = NormVertexTab[3+ThreeTimesI+2] ;
     else if(MAXX < NormVertexTab[3+ThreeTimesI  ] ) MAXX = NormVertexTab[3+ThreeTimesI  ] ;
     else if(MAXY < NormVertexTab[3+ThreeTimesI+1] ) MAXY = NormVertexTab[3+ThreeTimesI+1] ;
     else if(MAXZ < NormVertexTab[3+ThreeTimesI+2] ) MAXZ = NormVertexTab[3+ThreeTimesI+2] ;
                                }
  DIFX = MAXX - MINX ;
  DIFY = MAXY - MINY ;
  DIFZ = MAXZ - MINZ ;
// Recherche du maximum :
  DIFMAXIMUM = DIFX;
  if (DIFY > DIFMAXIMUM) {DIFMAXIMUM = DIFY;};
  if (DIFZ > DIFMAXIMUM) {DIFMAXIMUM = DIFZ;};
/// On va inclure cet objet dans un cube de langueur maximum
/// egale a "hauteur_fenetre"
double decalage_xo = -(MINX +MAXX)/2 ;
double decalage_yo = -(MINY +MAXY)/2 ;
double decalage_zo = -(MINZ +MAXZ)/2 ;
 for (i=0; i < NbVertexTmp ; i++) {
 ThreeTimesI = 2*3*i;
NormVertexTab[3+ThreeTimesI  ] = hauteur_fenetre*(NormVertexTab[3+ThreeTimesI  ] + decalage_xo)/DIFMAXIMUM ;
NormVertexTab[3+ThreeTimesI+1] = hauteur_fenetre*(NormVertexTab[3+ThreeTimesI+1] + decalage_yo)/DIFMAXIMUM ;
NormVertexTab[3+ThreeTimesI+2] = hauteur_fenetre*(NormVertexTab[3+ThreeTimesI+2] + decalage_zo)/DIFMAXIMUM ;
}

/// Index Polygones:
memcpy(IndexPolyTabMinPt, IndexPolyTabMin, PreviousSizeMinimalTopology*sizeof(GLuint));
*NbPolyMinPt = NbPolyMinimalTopology;

/// restaure the right value for step var:
step = step_local; // To save this value
/// Vertex :
memcpy(NormVertexTabPt, NormVertexTab, SixTimesNbVertexTmp*sizeof(GLfloat));
*VertexNumberpt = NbVertexTmp;
SaveSixTimesNbVertexTmp = SixTimesNbVertexTmp;
/// Index Triangles:
memcpy(IndexPolyTabPt, IndexPolyTab, ThreeTimesNbPolygnTmp*sizeof(GLuint));
SaveThreeTimesNbPolygnTmp = ThreeTimesNbPolygnTmp;
/// Nb Poly & Vertex :
memcpy(NbPolygnNbVertexPt,    NbPolygnNbVertex,   2*NbStep*sizeof(GLuint));
/// Poly Type :
memcpy(TypeIsoSurfaceTriangleListeCNDPt, TypeIsoSurfaceTriangleListeCND, NbTriangleIsoSurface*sizeof(int));

/// reactivate variables used for the 2D viewer:
if(drawaxe_ok == 1) {DrawAxe_Ok = 1;};

}
else{


morph_param = 0.0; // The starting point of the morph effect.
step_local = step; // To save this value
step = 1.0;


for(TmpImplicitEquation=0; TmpImplicitEquation<NbEquationsToDraw; TmpImplicitEquation++) {

       CurrentStep = TmpImplicitEquation; // To store infos NbPointIsoMap and NbTriangleIsoSurface
	   ImplicitFunction = ImplicitequationsCollection[CurrentStep];
       ParseExpression();
       VoxelEvaluation ();
       PointEdgeComputation();
       SignatureComputation();
       ConstructIsoSurface();
       ConstructIsoNormale();
	   SaveIsoGLMap();
	   SetMiniMmeshStructStream("", 3);
/// Save results :
// Save the Starting of the first Triangles for this specific Morph Step :
// Save the Index:
l = 0;
for ( i=0; i < NbTriangleIsoSurface ; ++i) {
ThreeTimesI = 3*i;
IndexPolyTab[l  + ThreeTimesNbPolygnTmp] = IsoSurfaceTriangleListe[ThreeTimesI  ] + NbVertexTmp;
IndexPolyTab[l+1+ ThreeTimesNbPolygnTmp] = IsoSurfaceTriangleListe[ThreeTimesI+1] + NbVertexTmp;
IndexPolyTab[l+2+ ThreeTimesNbPolygnTmp] = IsoSurfaceTriangleListe[ThreeTimesI+2] + NbVertexTmp;
l+=3;
}

// Save Number of Polys and vertex :
NbPolygnNbVertex[2*CurrentStep  ] = 3*NbTriangleIsoSurface;
NbPolygnNbVertex[2*CurrentStep+1] = ThreeTimesNbPolygnTmp;//ThreeTimesNbPolygnTmp;

NbVertexTmp           += NbPointIsoMap;
SixTimesNbVertexTmp    = 6*NbVertexTmp;
ThreeTimesNbPolygnTmp += 3*NbTriangleIsoSurface;
}
NbPolygnNbVertex[0]  = ThreeTimesNbPolygnTmp;

 for (i=0; i < NbVertexTmp  ; i++){
 ThreeTimesI = 6*i;
scalar = (double)sqrt((NormVertexTab[ThreeTimesI  ]*NormVertexTab[ThreeTimesI  ]) +
                      (NormVertexTab[ThreeTimesI+1]*NormVertexTab[ThreeTimesI+1]) +
                      (NormVertexTab[ThreeTimesI+2]*NormVertexTab[ThreeTimesI+2]));
if(scalar < 0.000000001)  scalar  = 0.000000001;
NormVertexTab[ThreeTimesI  ] /= scalar;
NormVertexTab[ThreeTimesI+1] /= scalar;
NormVertexTab[ThreeTimesI+2] /= scalar;
}


/// Put the object Inside a Cube :
MINX = 999999999;
MINY = 999999999;
MINZ = 999999999;

MAXX =-999999999;
MAXY =-999999999;
MAXZ =-999999999;
 for (i=0; i < NbVertexTmp; i++){
 ThreeTimesI = 2*3*i;
          if(MINX > NormVertexTab[3+ThreeTimesI  ] ) MINX = NormVertexTab[3+ThreeTimesI  ] ;
     else if(MINY > NormVertexTab[3+ThreeTimesI+1] ) MINY = NormVertexTab[3+ThreeTimesI+1] ;
     else if(MINZ > NormVertexTab[3+ThreeTimesI+2] ) MINZ = NormVertexTab[3+ThreeTimesI+2] ;
     else if(MAXX < NormVertexTab[3+ThreeTimesI  ] ) MAXX = NormVertexTab[3+ThreeTimesI  ] ;
     else if(MAXY < NormVertexTab[3+ThreeTimesI+1] ) MAXY = NormVertexTab[3+ThreeTimesI+1] ;
     else if(MAXZ < NormVertexTab[3+ThreeTimesI+2] ) MAXZ = NormVertexTab[3+ThreeTimesI+2] ;
                                }
  DIFX = MAXX - MINX ;
  DIFY = MAXY - MINY ;
  DIFZ = MAXZ - MINZ ;
// Recherche du maximum :
  DIFMAXIMUM = DIFX;
  if (DIFY > DIFMAXIMUM) {DIFMAXIMUM = DIFY;};
  if (DIFZ > DIFMAXIMUM) {DIFMAXIMUM = DIFZ;};
/// On va inclure cet objet dans un cube de langueur maximum
/// egale a "hauteur_fenetre"
double decalage_xo = -(MINX +MAXX)/2 ;
double decalage_yo = -(MINY +MAXY)/2 ;
double decalage_zo = -(MINZ +MAXZ)/2 ;
 for (i=0; i < NbVertexTmp ; i++) {
 ThreeTimesI = 2*3*i;
NormVertexTab[3+ThreeTimesI  ] = hauteur_fenetre*(NormVertexTab[3+ThreeTimesI  ] + decalage_xo)/DIFMAXIMUM ;
NormVertexTab[3+ThreeTimesI+1] = hauteur_fenetre*(NormVertexTab[3+ThreeTimesI+1] + decalage_yo)/DIFMAXIMUM ;
NormVertexTab[3+ThreeTimesI+2] = hauteur_fenetre*(NormVertexTab[3+ThreeTimesI+2] + decalage_zo)/DIFMAXIMUM ;
}

	/// Index Polygones:

memcpy(IndexPolyTabMinPt, IndexPolyTabMin, PreviousSizeMinimalTopology*sizeof(GLuint));
*NbPolyMinPt = NbPolyMinimalTopology;
/*
	/// Index Polygones:
SetMiniMmeshStructStream("", 3);
memcpy(IndexPolyTabMinPt, IndexPolyTabMin, ThreeTimesNbPolygnTmp*sizeof(GLuint));
*NbPolyMinPt = NbPolyMin;
*/
/// restaure the right value for step var:
step = step_local; // To save this value
/// Vertex :
memcpy(NormVertexTabPt, NormVertexTab, SixTimesNbVertexTmp*sizeof(GLfloat));
*VertexNumberpt = NbVertexTmp;
SaveSixTimesNbVertexTmp = SixTimesNbVertexTmp;
/// Index Triangles:
memcpy(IndexPolyTabPt, IndexPolyTab, ThreeTimesNbPolygnTmp*sizeof(GLuint));
SaveThreeTimesNbPolygnTmp = ThreeTimesNbPolygnTmp;
/// Nb Poly & Vertex :
memcpy(NbPolygnNbVertexPt,    NbPolygnNbVertex,   2*NbStep*sizeof(GLuint));
/// Poly Type :
memcpy(TypeIsoSurfaceTriangleListeCNDPt, TypeIsoSurfaceTriangleListeCND, NbTriangleIsoSurface*sizeof(int));



}
}

///+++++++++++++++++++++++++++++++++++++++++
  void Iso3D::RotateIsoMap() {
     Rotate();
     ApplicateTransform();
}

///+++++++++++++++++++++++++++++++++++++++++
   void Iso3D::Rotate(){
        MatRot.unit();
// Construction de la matrice de transformation
        MatRot.xrot(anglex);
        MatRot.yrot(angley);
//        MatGen.xrot(anglex);
//        MatGen.yrot(angley);
// On applique cette transformation a la matrice principale "mat"
        MatGen.mult(MatRot);
        MatRotSave.mult(MatRot);
}

///+++++++++++++++++++++++++++++++++++++++++
   void Iso3D::Scale(){
        MatSca.unit();
   // Construction de la matrice de transformation
        MatSca.xx = MatSca.yy = MatSca.zz = ScalCoeff;
   // On applique cette transformation a la matrice principale "mat"
        MatGen.mult(MatSca);
}

///++++++++++++++++++++++++++++++++++++++++
   void Iso3D::ScaleIsoMap(){
/*     Scale();
     ApplicateTransform();
*/
}

///+++++++++++++++++++++++++++++++++++++++++
   Iso3D::~Iso3D(){

    delete tableau;
    //for (i=0; i < maxgrscalemaxgr; i++)  {delete  tableaureferences[i];};
}

///+++++++++++++++++++++++++++++++++++++++++
   void Iso3D::ApplicateTransform(){
    double tp1, tp2, tp3;
    int ThreeTimesI;

/// Applicate Transformation to all points
   for (i=0; i < NbPointIsoMap ; i++){
        ThreeTimesI = 3*i;
        tp1 = IsoPointMapOriginal[ThreeTimesI    ];
        tp2 = IsoPointMapOriginal[ThreeTimesI + 1];
        tp3 = IsoPointMapOriginal[ThreeTimesI + 2];

IsoPointMapTransfrm[ThreeTimesI  ] = MatGen.xx*tp1 + MatGen.xy*tp2 +MatGen.xz*tp3 + MatGen.xo;

IsoPointMapTransfrm[ThreeTimesI+1] = MatGen.yx*tp1 + MatGen.yy*tp2 +MatGen.yz*tp3 + MatGen.yo;

IsoPointMapTransfrm[ThreeTimesI+2] = MatGen.zx*tp1 + MatGen.zy*tp2 +MatGen.zz*tp3 + MatGen.zo;
                                    }

/// Now, we transform Axes :
if (DrawAxe_Ok  == 1)
   for (i=0; i < 42 ; i++) {
        ThreeTimesI = 3*i;

/// X Axe :
        tp1 = AxeArrayOriginal[0][ThreeTimesI  ];
        tp2 = AxeArrayOriginal[0][ThreeTimesI+1];
        tp3 = AxeArrayOriginal[0][ThreeTimesI+2];
AxeArrayTransfrm[0][ThreeTimesI  ] = MatGen.xx*tp1 + MatGen.xy*tp2 +MatGen.xz*tp3 + MatGen.xo;
AxeArrayTransfrm[0][ThreeTimesI+1] = MatGen.yx*tp1 + MatGen.yy*tp2 +MatGen.yz*tp3 + MatGen.yo;
AxeArrayTransfrm[0][ThreeTimesI+2] = MatGen.zx*tp1 + MatGen.zy*tp2 +MatGen.zz*tp3 + MatGen.zo;

/// Y Axe :
        tp1 = AxeArrayOriginal[1][ThreeTimesI  ];
        tp2 = AxeArrayOriginal[1][ThreeTimesI+1];
        tp3 = AxeArrayOriginal[1][ThreeTimesI+2];
AxeArrayTransfrm[1][ThreeTimesI  ] = MatGen.xx*tp1 + MatGen.xy*tp2 +MatGen.xz*tp3 + MatGen.xo;
AxeArrayTransfrm[1][ThreeTimesI+1] = MatGen.yx*tp1 + MatGen.yy*tp2 +MatGen.yz*tp3 + MatGen.yo;
AxeArrayTransfrm[1][ThreeTimesI+2] = MatGen.zx*tp1 + MatGen.zy*tp2 +MatGen.zz*tp3 + MatGen.zo;

/// Z Axe :
        tp1 = AxeArrayOriginal[2][ThreeTimesI  ];
        tp2 = AxeArrayOriginal[2][ThreeTimesI+1];
        tp3 = AxeArrayOriginal[2][ThreeTimesI+2];
AxeArrayTransfrm[2][ThreeTimesI  ] = MatGen.xx*tp1 + MatGen.xy*tp2 +MatGen.xz*tp3 + MatGen.xo;
AxeArrayTransfrm[2][ThreeTimesI+1] = MatGen.yx*tp1 + MatGen.yy*tp2 +MatGen.yz*tp3 + MatGen.yo;
AxeArrayTransfrm[2][ThreeTimesI+2] = MatGen.zx*tp1 + MatGen.zy*tp2 +MatGen.zz*tp3 + MatGen.zo;
                                    }

//++++++++++++++++++++++++++++++++++++++++++
/// Now, we transform the Normal vectors :

   for (i=0; i < NbTriangleIsoSurface ; i++){
        ThreeTimesI = 3*i;
        tp1 = NormOriginal[ThreeTimesI    ];
        tp2 = NormOriginal[ThreeTimesI + 1];
        tp3 = NormOriginal[ThreeTimesI + 2];
NormTransfrm[ThreeTimesI  ] = MatRotSave.xx*tp1 + MatRotSave.xy*tp2 +MatRotSave.xz*tp3 + MatRotSave.xo;
NormTransfrm[ThreeTimesI+1] = MatRotSave.yx*tp1 + MatRotSave.yy*tp2 +MatRotSave.yz*tp3 + MatRotSave.yo;
NormTransfrm[ThreeTimesI+2] = MatRotSave.zx*tp1 + MatRotSave.zy*tp2 +MatRotSave.zz*tp3 + MatRotSave.zo;
                                      }
}
/*
///++++++++++++++++++++++++++++ Projection +++++++++++++++++++++++
   void Iso3D::ApplicateProjection(){
    double coefficient;
    int ThreeTimesI;

    for ( i=0; i < NbPointIsoMap; ++i) {
ThreeTimesI = 3*i;
coefficient = D/(IsoPointMapTransfrm[ThreeTimesI + 2]-Oprime[2]);
IsoPointMapProjectd[ThreeTimesI  ] = coefficient*IsoPointMapTransfrm[ThreeTimesI  ]  + demi_hauteur;
IsoPointMapProjectd[ThreeTimesI+1] = coefficient*IsoPointMapTransfrm[ThreeTimesI+1]  + demi_largeur;
IsoPointMapProjectd[ThreeTimesI+2] = IsoPointMapTransfrm[ThreeTimesI+2];
                                        }
}


void Iso3D::ReduiceTrianglesNumber(double precision){
       double x1,y1,z1,x2,y2,z2,x3,y3,z3;
for(i = 0; i < NbTriangleIsoSurface ; i++) {
IndexNbTriangle = i*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexThirdPoint;

x1 = IsoPointMapOriginal[3*IndexFirstPoint  ]-IsoPointMapOriginal[3*IndexSeconPoint  ];
y1 = IsoPointMapOriginal[3*IndexFirstPoint+1]-IsoPointMapOriginal[3*IndexSeconPoint+1];
z1 = IsoPointMapOriginal[3*IndexFirstPoint+2]-IsoPointMapOriginal[3*IndexSeconPoint+2];

x2 = IsoPointMapOriginal[3*IndexFirstPoint  ]-IsoPointMapOriginal[3*IndexThirdPoint  ];
y2 = IsoPointMapOriginal[3*IndexFirstPoint+1]-IsoPointMapOriginal[3*IndexThirdPoint+1];
z2 = IsoPointMapOriginal[3*IndexFirstPoint+2]-IsoPointMapOriginal[3*IndexThirdPoint+2];

x3 = IsoPointMapOriginal[3*IndexSeconPoint  ]-IsoPointMapOriginal[3*IndexThirdPoint  ];
y3 = IsoPointMapOriginal[3*IndexSeconPoint+1]-IsoPointMapOriginal[3*IndexThirdPoint+1];
z3 = IsoPointMapOriginal[3*IndexSeconPoint+2]-IsoPointMapOriginal[3*IndexThirdPoint+2];

if(
sqrt(x1*x1+y1*y1+z1*z1) > 0.01 &&
sqrt(x2*x2+y2*y2+z2*z2) > 0.01 &&
sqrt(x3*x3+y3*y3+z3*z3) > 0.01
  ) {


  }
}
   }
*/
///++++++++++++++++++++ ConstructIsoSurface +++++++++++++++++++++++++++
///void Iso3D::MinimalMeshObjFile(){
void Iso3D::SetMiniMmeshStructStream(QString filename, int filetype) {
    int Index, iter, nbpl, iterpl, savefilename=0, lnew;
    double AB[3], BC[3], CA[3], CE[3]; /// New Vertex
    int IA, IB, IC, AddedVertex=0; /// Index

    QFile file(filename);
    QString strstream="";
    QString strstream1="";
    QTextStream * stream = new QTextStream();
    QTextStream * stream1 = new QTextStream();

    if (filetype == 3){
    lnew = 0; 
	NbPolyMin = 0;
    /// Copy Index Polygons :
     for(i=0; i < nb_ligne-1 - CutLigne; i++){ I   = i*maxgrscalemaxgr;
     for(j=0; j < nb_colon-1 - CutColon; j++){ J   = I+j*maximumgrid;
     for(k=0; k < nb_depth-1 - CutDepth; k++){ IJK = J+k;
       Index = GridVoxelVarPt[IJK].Signature;
       nbpl = triTable_min[Index][16];

if( nbpl == 1){
NbPolyMin += nbpl;
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = triTable_min[Index][17];
for(iter = 0; iter < triTable_min[Index][17]; iter++)
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]  + NbVertexTmp;
}
else if( nbpl == 2){
NbPolyMin += nbpl;
/// First Poly:
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = triTable_min[Index][17];
for(iter = 0; iter < triTable_min[Index][17]; iter++)
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]  + NbVertexTmp;
/// Second Poly:
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = triTable_min[Index][18];
for(iter = triTable_min[Index][17]; iter < triTable_min[Index][17]+triTable_min[Index][18]; iter++)
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]  + NbVertexTmp;
}
else if( nbpl > 2) {
NbPolyMin += nbpl;
/// In this case we have only Triangles (3 or 4):
iter = 0;
for(iterpl = 0; iterpl < nbpl; iterpl++) {
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = 3;
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter  ]]  + NbVertexTmp;
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+1]]  + NbVertexTmp;
IndexPolyTabMin[PreviousSizeMinimalTopology + lnew++] = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+2]]  + NbVertexTmp;
iter +=3;
}
}

} /// End of for(k=0;............
} /// End of for(j=0;............
} /// End of for(i=0;............

	PreviousSizeMinimalTopology += lnew;
    NbPolyMinimalTopology += NbPolyMin;



}

/// Here we are going to save The minimal topology in a file
else {


if (filename.length()) {
    if ( file.open( IO_WriteOnly ) ) {
        stream  = new QTextStream(&file);
        stream1 = new QTextStream(&file);
        savefilename = 1;
    } /// End of if ( file.open( IO_WriteOnly ) )...
}
else {
    stream  = new QTextStream(&strstream,  IO_ReadWrite);
    stream1 = new QTextStream(&strstream1, IO_ReadWrite);
    savefilename = -1;
}



if (filetype == 0){
/// Copy Index Vertex :
for(i=0;i<NbPointIsoMap; i++) {
               Index = 6*i+3;
               *(stream) <<"v "<< NormVertexTab[Index  ]<<"  "\
                               << NormVertexTab[Index+1]<<"  "\
                               << NormVertexTab[Index+2]<<"\n";
}
/// Copy Index Polygons :
     for(i=0; i < nb_ligne-1 - CutLigne; i++){ I   = i*maxgrscalemaxgr;
     for(j=0; j < nb_colon-1 - CutColon; j++){ J   = I+j*maximumgrid;
     for(k=0; k < nb_depth-1 - CutDepth; k++){ IJK = J+k;
       Index = GridVoxelVarPt[IJK].Signature;
       nbpl = triTable_min[Index][16];
if( nbpl == 1){
*(stream) <<"f";
for(iter = 0; iter < triTable_min[Index][17]; iter++)
*(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1;
*(stream) <<"\n";
}
else if( nbpl == 2){
/// First Poly:
*(stream) <<"f";
for(iter = 0; iter < triTable_min[Index][17]; iter++)
*(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1;
*(stream) <<"\n";
/// Second Poly:
*(stream) <<"f";
for(iter = triTable_min[Index][17]; iter < triTable_min[Index][17]+triTable_min[Index][18]; iter++)
*(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1;
*(stream) <<"\n";
///stream <<"Case (2, "<<triTable_min[Index][17] <<" , "<<triTable_min[Index][18]<<")\n";
}

else if( nbpl > 2) {
/// In this case we have only Triangles (3 or 4):
iter = 0;
for(iterpl = 0; iterpl < nbpl; iterpl++) {
*(stream) <<"f  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter  ]]+1;
*(stream) <<"   "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+1]]+1;
*(stream) <<"   "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+2]]+1<<"\n" ;
iter +=3;
}
}

} /// End of for(k=0;............
} /// End of for(j=0;............
} /// End of for(i=0;............
}


else if (filetype == 1) {

/// Copy Index Vertex :
for(i=0;i<NbPointIsoMap; i++) {
               Index = 6*i+3;
               *(stream) <<"v "<< NormVertexTab[Index  ]<<"  "\
                               << NormVertexTab[Index+1]<<"  "\
                               << NormVertexTab[Index+2]<<"\n";
}
/// Copy Index Polygons :
     for(i=0; i < nb_ligne-1 - CutLigne; i++){ I   = i*maxgrscalemaxgr;
     for(j=0; j < nb_colon-1 - CutColon; j++){ J   = I+j*maximumgrid;
     for(k=0; k < nb_depth-1 - CutDepth; k++){ IJK = J+k;
       Index = GridVoxelVarPt[IJK].Signature;
       nbpl = triTable_min[Index][16];
if( nbpl == 1){
if(triTable_min[Index][17] > 3 ) {
*(stream) <<"f";
for(iter = 0; iter < triTable_min[Index][17]; iter++)
*(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1;
*(stream) <<"\n";
}
else{
IA = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][0]];
IB = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][1]];
IC = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][2]];
/*
/// Create new Vertex:
AB[0] = (IsoPointMapOriginal[3*IA  ] + IsoPointMapOriginal[3*IB  ])/2;
AB[1] = (IsoPointMapOriginal[3*IA+1] + IsoPointMapOriginal[3*IB+1])/2;
AB[2] = (IsoPointMapOriginal[3*IA+2] + IsoPointMapOriginal[3*IB+2])/2;

BC[0] = (IsoPointMapOriginal[3*IB  ] + IsoPointMapOriginal[3*IC  ])/2;
BC[1] = (IsoPointMapOriginal[3*IB+1] + IsoPointMapOriginal[3*IC+1])/2;
BC[2] = (IsoPointMapOriginal[3*IB+2] + IsoPointMapOriginal[3*IC+2])/2;

CA[0] = (IsoPointMapOriginal[3*IC  ] + IsoPointMapOriginal[3*IA  ])/2;
CA[1] = (IsoPointMapOriginal[3*IC+1] + IsoPointMapOriginal[3*IA+1])/2;
CA[2] = (IsoPointMapOriginal[3*IC+2] + IsoPointMapOriginal[3*IA+2])/2;
*/
/// Create new Vertex:
AB[0] = (NormVertexTab[3+6*IA  ] + NormVertexTab[3+6*IB  ])/2;
AB[1] = (NormVertexTab[3+6*IA+1] + NormVertexTab[3+6*IB+1])/2;
AB[2] = (NormVertexTab[3+6*IA+2] + NormVertexTab[3+6*IB+2])/2;

BC[0] = (NormVertexTab[3+6*IB  ] + NormVertexTab[3+6*IC  ])/2;
BC[1] = (NormVertexTab[3+6*IB+1] + NormVertexTab[3+6*IC+1])/2;
BC[2] = (NormVertexTab[3+6*IB+2] + NormVertexTab[3+6*IC+2])/2;

CA[0] = (NormVertexTab[3+6*IC  ] + NormVertexTab[3+6*IA  ])/2;
CA[1] = (NormVertexTab[3+6*IC+1] + NormVertexTab[3+6*IA+1])/2;
CA[2] = (NormVertexTab[3+6*IC+2] + NormVertexTab[3+6*IA+2])/2;

CE[0] = (NormVertexTab[3+6*IC  ]+
         NormVertexTab[3+6*IB  ]+
         NormVertexTab[3+6*IA  ])/3;
CE[1] = (NormVertexTab[3+6*IC+1]+
         NormVertexTab[3+6*IB+1]+
         NormVertexTab[3+6*IA+1])/3;
CE[2] = (NormVertexTab[3+6*IC+2]+
         NormVertexTab[3+6*IB+2]+
         NormVertexTab[3+6*IA+2])/3;
/// Store theses Infos:
*(stream1) <<"v "<<AB[0]<<"  "<<AB[1]<<"  "<<AB[2]<<"\n";
*(stream1) <<"v "<<BC[0]<<"  "<<BC[1]<<"  "<<BC[2]<<"\n";
*(stream1) <<"v "<<CA[0]<<"  "<<CA[1]<<"  "<<CA[2]<<"\n";
*(stream1) <<"v "<<CE[0]<<"  "<<CE[1]<<"  "<<CE[2]<<"\n";

*(stream) <<"f "<<IA+1<<"  "<<NbPointIsoMap+AddedVertex+1<<"  "\
                           <<NbPointIsoMap+AddedVertex+4<<"  "\
						   <<NbPointIsoMap+AddedVertex+3<<"\n";
*(stream) <<"f "<<NbPointIsoMap+AddedVertex+1<<"  "<<IB+1<<"  "\
               <<NbPointIsoMap+AddedVertex+2<<"  "\
			   <<NbPointIsoMap+AddedVertex+4<<"\n";
*(stream) <<"f "<<NbPointIsoMap+AddedVertex+2<<"  "<<IC+1<<"  "\
               <<NbPointIsoMap+AddedVertex+3<<"  "\
			   <<NbPointIsoMap+AddedVertex+4<<"\n";
AddedVertex +=4;
}


}



else if( nbpl == 2){
/// First Poly:
if(triTable_min[Index][17] > 3 ) {
*(stream) <<"f";
for(iter = 0; iter < triTable_min[Index][17]; iter++)
*(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1 ;
*(stream) <<"\n";
}
else{
IA = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][0]];
IB = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][1]];
IC = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][2]];
/// Create new Vertex:
AB[0] = (NormVertexTab[3+6*IA  ] + NormVertexTab[3+6*IB  ])/2;
AB[1] = (NormVertexTab[3+6*IA+1] + NormVertexTab[3+6*IB+1])/2;
AB[2] = (NormVertexTab[3+6*IA+2] + NormVertexTab[3+6*IB+2])/2;

BC[0] = (NormVertexTab[3+6*IB  ] + NormVertexTab[3+6*IC  ])/2;
BC[1] = (NormVertexTab[3+6*IB+1] + NormVertexTab[3+6*IC+1])/2;
BC[2] = (NormVertexTab[3+6*IB+2] + NormVertexTab[3+6*IC+2])/2;

CA[0] = (NormVertexTab[3+6*IC  ] + NormVertexTab[3+6*IA  ])/2;
CA[1] = (NormVertexTab[3+6*IC+1] + NormVertexTab[3+6*IA+1])/2;
CA[2] = (NormVertexTab[3+6*IC+2] + NormVertexTab[3+6*IA+2])/2;

CE[0] = (NormVertexTab[3+6*IC  ]+
         NormVertexTab[3+6*IB  ]+
         NormVertexTab[3+6*IA  ])/3;
CE[1] = (NormVertexTab[3+6*IC+1]+
         NormVertexTab[3+6*IB+1]+
         NormVertexTab[3+6*IA+1])/3;
CE[2] = (NormVertexTab[3+6*IC+2]+
         NormVertexTab[3+6*IB+2]+
         NormVertexTab[3+6*IA+2])/3;
/// Store theses Infos:
*(stream1) <<"v "<<AB[0]<<"  "<<AB[1]<<"  "<<AB[2]<<"\n";
*(stream1) <<"v "<<BC[0]<<"  "<<BC[1]<<"  "<<BC[2]<<"\n";
*(stream1) <<"v "<<CA[0]<<"  "<<CA[1]<<"  "<<CA[2]<<"\n";
*(stream1) <<"v "<<CE[0]<<"  "<<CE[1]<<"  "<<CE[2]<<"\n";

*(stream) <<"f "<<IA+1<<"  "<<NbPointIsoMap+AddedVertex+1<<"  "\
                         <<NbPointIsoMap+AddedVertex+4<<"  "\
						 <<NbPointIsoMap+AddedVertex+3<<"\n";

*(stream) <<"f "<<NbPointIsoMap+AddedVertex+1<<"  "<<IB+1<<"  "\
               <<NbPointIsoMap+AddedVertex+2<<"  "\
			   <<NbPointIsoMap+AddedVertex+4<<"\n";

*(stream) <<"f "<<NbPointIsoMap+AddedVertex+2<<"  "<<IC+1<<"  "\
               <<NbPointIsoMap+AddedVertex+3<<"  "\
			   <<NbPointIsoMap+AddedVertex+4<<"\n";
AddedVertex +=4;
}


/// Second Poly:
if(triTable_min[Index][18] > 3 ) {
*(stream) <<"f";
for(iter = triTable_min[Index][17]; iter < triTable_min[Index][17]+triTable_min[Index][18]; iter++)
*(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1;
*(stream) <<"\n";
}
else{
IA = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][triTable_min[Index][17]]];
IB = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][triTable_min[Index][17]+1]];
IC = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][triTable_min[Index][17]+2]];
/// Create new Vertex:
AB[0] = (NormVertexTab[3+6*IA  ] + NormVertexTab[3+6*IB  ])/2;
AB[1] = (NormVertexTab[3+6*IA+1] + NormVertexTab[3+6*IB+1])/2;
AB[2] = (NormVertexTab[3+6*IA+2] + NormVertexTab[3+6*IB+2])/2;

BC[0] = (NormVertexTab[3+6*IB  ] + NormVertexTab[3+6*IC  ])/2;
BC[1] = (NormVertexTab[3+6*IB+1] + NormVertexTab[3+6*IC+1])/2;
BC[2] = (NormVertexTab[3+6*IB+2] + NormVertexTab[3+6*IC+2])/2;

CA[0] = (NormVertexTab[3+6*IC  ] + NormVertexTab[3+6*IA  ])/2;
CA[1] = (NormVertexTab[3+6*IC+1] + NormVertexTab[3+6*IA+1])/2;
CA[2] = (NormVertexTab[3+6*IC+2] + NormVertexTab[3+6*IA+2])/2;

CE[0] = (NormVertexTab[3+6*IC  ]+
         NormVertexTab[3+6*IB  ]+
         NormVertexTab[3+6*IA  ])/3;
CE[1] = (NormVertexTab[3+6*IC+1]+
         NormVertexTab[3+6*IB+1]+
         NormVertexTab[3+6*IA+1])/3;
CE[2] = (NormVertexTab[3+6*IC+2]+
         NormVertexTab[3+6*IB+2]+
         NormVertexTab[3+6*IA+2])/3;
/// Store theses Infos:
*(stream1) <<"v "<<AB[0]<<"  "<<AB[1]<<"  "<<AB[2]<<"\n";
*(stream1) <<"v "<<BC[0]<<"  "<<BC[1]<<"  "<<BC[2]<<"\n";
*(stream1) <<"v "<<CA[0]<<"  "<<CA[1]<<"  "<<CA[2]<<"\n";
*(stream1) <<"v "<<CE[0]<<"  "<<CE[1]<<"  "<<CE[2]<<"\n";

*(stream) <<"f "<<IA+1<<"  "<<NbPointIsoMap+AddedVertex+1<<"  "\
                            <<NbPointIsoMap+AddedVertex+4<<"  "\
                            <<NbPointIsoMap+AddedVertex+3<<"\n";

*(stream) <<"f "<<NbPointIsoMap+AddedVertex+1<<"  "<<IB+1<<"  "\
                <<NbPointIsoMap+AddedVertex+2<<"  "\
                <<NbPointIsoMap+AddedVertex+4<<"\n";

*(stream) <<"f "<<NbPointIsoMap+AddedVertex+2<<"  "<<IC+1<<"  "\
                <<NbPointIsoMap+AddedVertex+3<<"  "\
                <<NbPointIsoMap+AddedVertex+4<<"\n";
AddedVertex +=4;
}
}


else if( nbpl > 2) {
/// In this case we have only Triangles (3 or 4):
iter = 0;
for(iterpl = 0; iterpl < nbpl; iterpl++) {

*(stream) <<"f  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter  ]]+1;
*(stream) <<"   "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+1]]+1;
*(stream) <<"   "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+2]]+1<<"\n" ;
{
IA = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter  ]];
IB = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+1]];
IC = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+2]];
/// Create new Vertex:
AB[0] = (NormVertexTab[3+6*IA  ] + NormVertexTab[3+6*IB  ])/2;
AB[1] = (NormVertexTab[3+6*IA+1] + NormVertexTab[3+6*IB+1])/2;
AB[2] = (NormVertexTab[3+6*IA+2] + NormVertexTab[3+6*IB+2])/2;

BC[0] = (NormVertexTab[3+6*IB  ] + NormVertexTab[3+6*IC  ])/2;
BC[1] = (NormVertexTab[3+6*IB+1] + NormVertexTab[3+6*IC+1])/2;
BC[2] = (NormVertexTab[3+6*IB+2] + NormVertexTab[3+6*IC+2])/2;

CA[0] = (NormVertexTab[3+6*IC  ] + NormVertexTab[3+6*IA  ])/2;
CA[1] = (NormVertexTab[3+6*IC+1] + NormVertexTab[3+6*IA+1])/2;
CA[2] = (NormVertexTab[3+6*IC+2] + NormVertexTab[3+6*IA+2])/2;

CE[0] = (NormVertexTab[3+6*IC  ]+
         NormVertexTab[3+6*IB  ]+
         NormVertexTab[3+6*IA  ])/3;
CE[1] = (NormVertexTab[3+6*IC+1]+
         NormVertexTab[3+6*IB+1]+
         NormVertexTab[3+6*IA+1])/3;
CE[2] = (NormVertexTab[3+6*IC+2]+
         NormVertexTab[3+6*IB+2]+
         NormVertexTab[3+6*IA+2])/3;
/// Store theses Infos:
*(stream1) <<"v "<<AB[0]<<"  "<<AB[1]<<"  "<<AB[2]<<"\n";
*(stream1) <<"v "<<BC[0]<<"  "<<BC[1]<<"  "<<BC[2]<<"\n";
*(stream1) <<"v "<<CA[0]<<"  "<<CA[1]<<"  "<<CA[2]<<"\n";
*(stream1) <<"v "<<CE[0]<<"  "<<CE[1]<<"  "<<CE[2]<<"\n";

*(stream) <<"f "<<IA+1<<"  "<<NbPointIsoMap+AddedVertex+1<<"  "\
                <<NbPointIsoMap+AddedVertex+4<<"  "\
                <<NbPointIsoMap+AddedVertex+3<<"\n";

*(stream) <<"f "<<NbPointIsoMap+AddedVertex+1<<"  "<<IB+1<<"  "\
               <<NbPointIsoMap+AddedVertex+2<<"  "\
               <<NbPointIsoMap+AddedVertex+4<<"\n";

*(stream) <<"f "<<NbPointIsoMap+AddedVertex+2<<"  "<<IC+1<<"  "\
                <<NbPointIsoMap+AddedVertex+3<<"  "\
                <<NbPointIsoMap+AddedVertex+4<<"\n";
AddedVertex +=4;
}
iter +=3;
}
}
} /// End of for(k=0;............
} /// End of for(j=0;............
} /// End of for(i=0;............
}
//memcpy(NormVertexTabPt, NormVertexTab, SixTimesNbVertexTmp*sizeof(GLfloat));
else if (filetype == 2){
/// Copy Index Vertex :
for(i=0; i < SaveSixTimesNbVertexTmp; i+=6) {
               *(stream) <<"v "<< NormVertexTab[i+3] <<"  "\
                               << NormVertexTab[i+4] <<"  "\
                               << NormVertexTab[i+5] <<"\n";
}
/// Copy Index Polygons :
for(i = 0; i < SaveThreeTimesNbPolygnTmp; i+=3) {
if(TypeIsoSurfaceTriangleListeCND[(int)(i/3)] == 1 )
*(stream) <<"f  "<< IndexPolyTab[i  ]+1 <<"   "\
                 << IndexPolyTab[i+1]+1 <<"   "\
                 << IndexPolyTab[i+2]+1 <<"\n";
}
} // End if (filetype == 2)


  if (savefilename == 1) file.close();
  else {
  editeur * edit = new editeur();
  edit->e->setText(strstream1+strstream);
  edit->show();
  }
}
}

///++++++++++++++++++++ ConstructIsoSurface +++++++++++++++++++++++++++
static int TrianglToQuad =-1;
void Iso3D::SetMinimuMmeshStruct() {
    int Index, iter, nbpl, iterpl;
    double AB[3], BC[3], CA[3], CE[3]; /// New Vertex
    int IA, IB, IC, AddedVertex=0; /// Index
    QString strstream;
    QTextStream stream(&strstream, IO_ReadWrite);
    QString strstream1;
    QTextStream stream1(&strstream1, IO_ReadWrite);
/// Copy Index Vertex :
for(i=0;i<NbPointIsoMap; i++) {
               Index = 3*i;
               (stream1) <<"v "<<IsoPointMapOriginal[Index  ]<<"  "\
                               <<IsoPointMapOriginal[Index+1]<<"  "\
                               <<IsoPointMapOriginal[Index+2]<<"\n";
}
/// Copy Index Polygons :
     for(i=0; i < nb_ligne-1 - CutLigne; i++){ I   = i*maxgrscalemaxgr;
     for(j=0; j < nb_colon-1 - CutColon; j++){ J   = I+j*maximumgrid;
     for(k=0; k < nb_depth-1 - CutDepth; k++){ IJK = J+k;
       Index = GridVoxelVarPt[IJK].Signature;
       nbpl = triTable_min[Index][16];
if( nbpl == 1){
if(triTable_min[Index][17] > 3 || TrianglToQuad !=1) {
(stream) <<"f";
for(iter = 0; iter < triTable_min[Index][17]; iter++)
(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1;
(stream) <<"\n";
}
else{
IA = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][0]];
IB = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][1]];
IC = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][2]];
/// Create new Vertex:
AB[0] = (NormVertexTab[3+6*IA  ] + NormVertexTab[3+6*IB  ])/2;
AB[1] = (NormVertexTab[3+6*IA+1] + NormVertexTab[3+6*IB+1])/2;
AB[2] = (NormVertexTab[3+6*IA+2] + NormVertexTab[3+6*IB+2])/2;

BC[0] = (NormVertexTab[3+6*IB  ] + NormVertexTab[3+6*IC  ])/2;
BC[1] = (NormVertexTab[3+6*IB+1] + NormVertexTab[3+6*IC+1])/2;
BC[2] = (NormVertexTab[3+6*IB+2] + NormVertexTab[3+6*IC+2])/2;

CA[0] = (NormVertexTab[3+6*IC  ] + NormVertexTab[3+6*IA  ])/2;
CA[1] = (NormVertexTab[3+6*IC+1] + NormVertexTab[3+6*IA+1])/2;
CA[2] = (NormVertexTab[3+6*IC+2] + NormVertexTab[3+6*IA+2])/2;

CE[0] = (NormVertexTab[3+6*IC  ]+
         NormVertexTab[3+6*IB  ]+
         NormVertexTab[3+6*IA  ])/3;
CE[1] = (NormVertexTab[3+6*IC+1]+
         NormVertexTab[3+6*IB+1]+
         NormVertexTab[3+6*IA+1])/3;
CE[2] = (NormVertexTab[3+6*IC+2]+
         NormVertexTab[3+6*IB+2]+
         NormVertexTab[3+6*IA+2])/3;
/// Store theses Infos:
(stream1) <<"v "<<AB[0]<<"  "<<AB[1]<<"  "<<AB[2]<<"\n";
(stream1) <<"v "<<BC[0]<<"  "<<BC[1]<<"  "<<BC[2]<<"\n";
(stream1) <<"v "<<CA[0]<<"  "<<CA[1]<<"  "<<CA[2]<<"\n";
(stream1) <<"v "<<CE[0]<<"  "<<CE[1]<<"  "<<CE[2]<<"\n";

(stream) <<"f "<<IA+1<<"  "<<NbPointIsoMap+AddedVertex+1<<"  "\
                           <<NbPointIsoMap+AddedVertex+4<<"  "\
						   <<NbPointIsoMap+AddedVertex+3<<"\n";

(stream) <<"f "<<NbPointIsoMap+AddedVertex+1<<"  "<<IB+1<<"  "\
               <<NbPointIsoMap+AddedVertex+2<<"  "\
			   <<NbPointIsoMap+AddedVertex+4<<"\n";

(stream) <<"f "<<NbPointIsoMap+AddedVertex+2<<"  "<<IC+1<<"  "\
               <<NbPointIsoMap+AddedVertex+3<<"  "\
			   <<NbPointIsoMap+AddedVertex+4<<"\n";

AddedVertex +=4;
}
}


else if( nbpl == 2){
/// First Poly:
if(triTable_min[Index][17] > 3 || TrianglToQuad !=1) {
(stream) <<"f";
for(iter = 0; iter < triTable_min[Index][17]; iter++)
(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1;
(stream) <<"\n";
}
else{
IA = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][0]];
IB = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][1]];
IC = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][2]];
/// Create new Vertex:
AB[0] = (NormVertexTab[3+6*IA  ] + NormVertexTab[3+6*IB  ])/2;
AB[1] = (NormVertexTab[3+6*IA+1] + NormVertexTab[3+6*IB+1])/2;
AB[2] = (NormVertexTab[3+6*IA+2] + NormVertexTab[3+6*IB+2])/2;

BC[0] = (NormVertexTab[3+6*IB  ] + NormVertexTab[3+6*IC  ])/2;
BC[1] = (NormVertexTab[3+6*IB+1] + NormVertexTab[3+6*IC+1])/2;
BC[2] = (NormVertexTab[3+6*IB+2] + NormVertexTab[3+6*IC+2])/2;

CA[0] = (NormVertexTab[3+6*IC  ] + NormVertexTab[3+6*IA  ])/2;
CA[1] = (NormVertexTab[3+6*IC+1] + NormVertexTab[3+6*IA+1])/2;
CA[2] = (NormVertexTab[3+6*IC+2] + NormVertexTab[3+6*IA+2])/2;

CE[0] = (NormVertexTab[3+6*IC  ]+
         NormVertexTab[3+6*IB  ]+
         NormVertexTab[3+6*IA  ])/3;
CE[1] = (NormVertexTab[3+6*IC+1]+
         NormVertexTab[3+6*IB+1]+
         NormVertexTab[3+6*IA+1])/3;
CE[2] = (NormVertexTab[3+6*IC+2]+
         NormVertexTab[3+6*IB+2]+
         NormVertexTab[3+6*IA+2])/3;
/// Store theses Infos:
(stream1) <<"v "<<AB[0]<<"  "<<AB[1]<<"  "<<AB[2]<<"\n";
(stream1) <<"v "<<BC[0]<<"  "<<BC[1]<<"  "<<BC[2]<<"\n";
(stream1) <<"v "<<CA[0]<<"  "<<CA[1]<<"  "<<CA[2]<<"\n";
(stream1) <<"v "<<CE[0]<<"  "<<CE[1]<<"  "<<CE[2]<<"\n";

(stream) <<"f "<<IA+1<<"  "<<NbPointIsoMap+AddedVertex+1<<"  "\
                           <<NbPointIsoMap+AddedVertex+4<<"  "\
                           <<NbPointIsoMap+AddedVertex+3<<"\n";

(stream) <<"f "<<NbPointIsoMap+AddedVertex+1<<"  "<<IB+1<<"  "\
               <<NbPointIsoMap+AddedVertex+2<<"  "\
               <<NbPointIsoMap+AddedVertex+4<<"\n";

(stream) <<"f "<<NbPointIsoMap+AddedVertex+2<<"  "<<IC+1<<"  "\
               <<NbPointIsoMap+AddedVertex+3<<"  "\
               <<NbPointIsoMap+AddedVertex+4<<"\n";
AddedVertex +=4;
}



/// Second Poly:
if(triTable_min[Index][18] > 3 || TrianglToQuad !=1) {
(stream) <<"f";
for(iter = triTable_min[Index][17]; iter < triTable_min[Index][17]+triTable_min[Index][18]; iter++)
(stream) <<"  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter]]+1;
(stream) <<"\n";
}
else{
IA = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][triTable_min[Index][17]]];
IB = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][triTable_min[Index][17]+1]];
IC = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][triTable_min[Index][17]+2]];
/// Create new Vertex:
AB[0] = (NormVertexTab[3+6*IA  ] + NormVertexTab[3+6*IB  ])/2;
AB[1] = (NormVertexTab[3+6*IA+1] + NormVertexTab[3+6*IB+1])/2;
AB[2] = (NormVertexTab[3+6*IA+2] + NormVertexTab[3+6*IB+2])/2;

BC[0] = (NormVertexTab[3+6*IB  ] + NormVertexTab[3+6*IC  ])/2;
BC[1] = (NormVertexTab[3+6*IB+1] + NormVertexTab[3+6*IC+1])/2;
BC[2] = (NormVertexTab[3+6*IB+2] + NormVertexTab[3+6*IC+2])/2;

CA[0] = (NormVertexTab[3+6*IC  ] + NormVertexTab[3+6*IA  ])/2;
CA[1] = (NormVertexTab[3+6*IC+1] + NormVertexTab[3+6*IA+1])/2;
CA[2] = (NormVertexTab[3+6*IC+2] + NormVertexTab[3+6*IA+2])/2;

CE[0] = (NormVertexTab[3+6*IC  ]+
         NormVertexTab[3+6*IB  ]+
         NormVertexTab[3+6*IA  ])/3;
CE[1] = (NormVertexTab[3+6*IC+1]+
         NormVertexTab[3+6*IB+1]+
         NormVertexTab[3+6*IA+1])/3;
CE[2] = (NormVertexTab[3+6*IC+2]+
         NormVertexTab[3+6*IB+2]+
         NormVertexTab[3+6*IA+2])/3;
/// Store theses Infos:
(stream1) <<"v "<<AB[0]<<"  "<<AB[1]<<"  "<<AB[2]<<"\n";
(stream1) <<"v "<<BC[0]<<"  "<<BC[1]<<"  "<<BC[2]<<"\n";
(stream1) <<"v "<<CA[0]<<"  "<<CA[1]<<"  "<<CA[2]<<"\n";
(stream1) <<"v "<<CE[0]<<"  "<<CE[1]<<"  "<<CE[2]<<"\n";

(stream) <<"f "<<IA+1<<"  "<<NbPointIsoMap+AddedVertex+1<<"  "\
                           <<NbPointIsoMap+AddedVertex+4<<"  "\
                           <<NbPointIsoMap+AddedVertex+3<<"\n";

(stream) <<"f "<<NbPointIsoMap+AddedVertex+1<<"  "<<IB+1<<"  "\
               <<NbPointIsoMap+AddedVertex+2<<"  "\
               <<NbPointIsoMap+AddedVertex+4<<"\n";

(stream) <<"f "<<NbPointIsoMap+AddedVertex+2<<"  "<<IC+1<<"  "\
               <<NbPointIsoMap+AddedVertex+3<<"  "\
               <<NbPointIsoMap+AddedVertex+4<<"\n";
AddedVertex +=4;
}
}




else if( nbpl > 2) {
/// In this case we have only Triangles (3 or 4):
iter = 0;
for(iterpl = 0; iterpl < nbpl; iterpl++) {
if(TrianglToQuad !=1){
(stream) <<"f  "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter  ]]+1;
(stream) <<"   "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+1]]+1;
(stream) <<"   "<<GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+2]]+1<<"\n" ;
}

else{
IA = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter  ]];
IB = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+1]];
IC = GridVoxelVarPt[IJK].Edge_Points[triTable_min[Index][iter+2]];
/// Create new Vertex:
AB[0] = (NormVertexTab[3+6*IA  ] + NormVertexTab[3+6*IB  ])/2;
AB[1] = (NormVertexTab[3+6*IA+1] + NormVertexTab[3+6*IB+1])/2;
AB[2] = (NormVertexTab[3+6*IA+2] + NormVertexTab[3+6*IB+2])/2;

BC[0] = (NormVertexTab[3+6*IB  ] + NormVertexTab[3+6*IC  ])/2;
BC[1] = (NormVertexTab[3+6*IB+1] + NormVertexTab[3+6*IC+1])/2;
BC[2] = (NormVertexTab[3+6*IB+2] + NormVertexTab[3+6*IC+2])/2;

CA[0] = (NormVertexTab[3+6*IC  ] + NormVertexTab[3+6*IA  ])/2;
CA[1] = (NormVertexTab[3+6*IC+1] + NormVertexTab[3+6*IA+1])/2;
CA[2] = (NormVertexTab[3+6*IC+2] + NormVertexTab[3+6*IA+2])/2;

CE[0] = (NormVertexTab[3+6*IC  ]+
         NormVertexTab[3+6*IB  ]+
         NormVertexTab[3+6*IA  ])/3;
CE[1] = (NormVertexTab[3+6*IC+1]+
         NormVertexTab[3+6*IB+1]+
         NormVertexTab[3+6*IA+1])/3;
CE[2] = (NormVertexTab[3+6*IC+2]+
         NormVertexTab[3+6*IB+2]+
         NormVertexTab[3+6*IA+2])/3;
/// Store theses Infos:
(stream1) <<"v "<<AB[0]<<"  "<<AB[1]<<"  "<<AB[2]<<"\n";
(stream1) <<"v "<<BC[0]<<"  "<<BC[1]<<"  "<<BC[2]<<"\n";
(stream1) <<"v "<<CA[0]<<"  "<<CA[1]<<"  "<<CA[2]<<"\n";
(stream1) <<"v "<<CE[0]<<"  "<<CE[1]<<"  "<<CE[2]<<"\n";

(stream) <<"f "<<IA+1<<"  "<<NbPointIsoMap+AddedVertex+1<<"  "\
                           <<NbPointIsoMap+AddedVertex+4<<"  "\
                           <<NbPointIsoMap+AddedVertex+3<<"\n";

(stream) <<"f "<<NbPointIsoMap+AddedVertex+1<<"  "<<IB+1<<"  "\
               <<NbPointIsoMap+AddedVertex+2<<"  "\
               <<NbPointIsoMap+AddedVertex+4<<"\n";

(stream) <<"f "<<NbPointIsoMap+AddedVertex+2<<"  "<<IC+1<<"  "\
               <<NbPointIsoMap+AddedVertex+3<<"  "\
               <<NbPointIsoMap+AddedVertex+4<<"\n";
AddedVertex +=4;
}

iter +=3;
}
}

} /// End of for(k=0;............
} /// End of for(j=0;............
} /// End of for(i=0;............


editeur * edit = new editeur();
edit->e->setText(strstream1+strstream);
edit->show();
}

///++++++++++++++++++++ ConstructIsoSurface +++++++++++++++++++++++++++
   void Iso3D::ConstructIsoSurface(){
    int IndexNbTriangle, Alfa, Index, IndexPoint, IndexFirstPoint,
        IndexSeconPoint, IndexThirdPoint,
        IndexAprime, IndexBprime, IndexCprime;
    double  Aprime[4], Bprime[4], Cprime[4],
            DiffX, DiffY, DiffZ;

NbTriangleIsoSurface = 0;
NbPointIsoMapCND = 0;
NbTriangleIsoSurfaceCND = 0;

if(IsoConditionRequired == -1 )
     for(i=0; i < nb_ligne-1 - CutLigne; i++){ I   = i*maxgrscalemaxgr;
     for(j=0; j < nb_colon-1 - CutColon; j++){ J   = I+j*maximumgrid;
     for(k=0; k < nb_depth-1 - CutDepth; k++){ IJK = J+k;
       Index = GridVoxelVarPt[IJK].Signature;
for (l = 0; triTable[Index][l] != -1 && NbTriangleIsoSurface < NbPolygonImposedLimit; l += 3)
{
IndexFirstPoint = GridVoxelVarPt[IJK].Edge_Points[triTable[Index][l  ]];
IndexSeconPoint = GridVoxelVarPt[IJK].Edge_Points[triTable[Index][l+1]];
IndexThirdPoint = GridVoxelVarPt[IJK].Edge_Points[triTable[Index][l+2]];
{
if(IndexFirstPoint != -20 && IndexSeconPoint != -20 && IndexThirdPoint != -20 ) {
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexThirdPoint;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1; /// Normals Triangles
NbTriangleIsoSurface++;
}}}
}}}

/// Here we have to compute some missing points...
else
     for(i=0; i < nb_ligne-1 - CutLigne; i++)
     for(k=0; k < nb_depth-1 - CutDepth; k++)
     for(j=0; j < nb_colon-1 - CutColon; j++)
 {  IJK = i*maxgrscalemaxgr+j*maximumgrid+k;
       Index = GridVoxelVarPt[IJK].Signature;
for (l = 0; triTable[Index][l] != -1 && NbTriangleIsoSurface < NbPolygonImposedLimit; l += 3) {
IndexFirstPoint = GridVoxelVarPt[IJK].Edge_Points[triTable[Index][l  ]];
IndexSeconPoint = GridVoxelVarPt[IJK].Edge_Points[triTable[Index][l+1]];
IndexThirdPoint = GridVoxelVarPt[IJK].Edge_Points[triTable[Index][l+2]];

if(IndexFirstPoint != -20 && IndexSeconPoint != -20 && IndexThirdPoint != -20){

///+++++++++++++++++++++++++++++ First Case +++++++++++++++++++++++++++++++++++++++++++///
/// All points verifient the condition
if(WichPointVeryCond[IndexFirstPoint]*WichPointVeryCond[IndexSeconPoint]*WichPointVeryCond[IndexThirdPoint] !=0) {
IsoSurfaceTriangleListe[NbTriangleIsoSurface*3  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[NbTriangleIsoSurface*3+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[NbTriangleIsoSurface*3+2] = IndexThirdPoint;
///All points in this triangle verify the condition. Type = 1
/// There is no new Isopoints to Add.
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;
    }/// End if(WichPointVeryCond[IndexFirstPoint]...

///+++++++++++++++++ Second Case ++++++++++++++++++++++++++++++++++++++++++///
/// All points don't verify the condition
else if (WichPointVeryCond[IndexFirstPoint] == 0 &&
         WichPointVeryCond[IndexSeconPoint] == 0 &&
         WichPointVeryCond[IndexThirdPoint] == 0) {

IsoSurfaceTriangleListe[NbTriangleIsoSurface*3  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[NbTriangleIsoSurface*3+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[NbTriangleIsoSurface*3+2] = IndexThirdPoint;

///All points in this triangle verify the condition. Type = 0
/// There is no new Isopoints to Add.
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;
}

///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++///
/// We still have 6 cases to treat here
else {
if(WichPointVeryCond[IndexFirstPoint] == 0) {
 if(WichPointVeryCond[IndexSeconPoint] == 0){
  if(WichPointVeryCond[IndexThirdPoint] != 0){
///  First Case : A == 0; B == 0; C != 0
/// Compute 2 points : Aprime and Bprime
/// Aprime
Aprime[0] = NormVertexTab[3+6*IndexThirdPoint  ];
Aprime[1] = NormVertexTab[3+6*IndexThirdPoint+1];
Aprime[2] = NormVertexTab[3+6*IndexThirdPoint+2];

DiffX = (NormVertexTab[3+6*IndexFirstPoint  ] - NormVertexTab[3+6*IndexThirdPoint  ])/10.;
DiffY = (NormVertexTab[3+6*IndexFirstPoint+1] - NormVertexTab[3+6*IndexThirdPoint+1])/10.;
DiffZ = (NormVertexTab[3+6*IndexFirstPoint+2] - NormVertexTab[3+6*IndexThirdPoint+2])/10.;
Alfa = 0;

while((IsoConditionParser.Eval(Aprime) == 1) && (Alfa < 10)) {
Aprime[0] += DiffX;
Aprime[1] += DiffY;
Aprime[2] += DiffZ;
Alfa += 1;
}

/// Bprime
Bprime[0] = NormVertexTab[3+6*IndexThirdPoint  ];
Bprime[1] = NormVertexTab[3+6*IndexThirdPoint+1];
Bprime[2] = NormVertexTab[3+6*IndexThirdPoint+2];

DiffX = (NormVertexTab[3+6*IndexSeconPoint  ] - NormVertexTab[3+6*IndexThirdPoint  ])/10.;
DiffY = (NormVertexTab[3+6*IndexSeconPoint+1] - NormVertexTab[3+6*IndexThirdPoint+1])/10.;
DiffZ = (NormVertexTab[3+6*IndexSeconPoint+2] - NormVertexTab[3+6*IndexThirdPoint+2])/10.;
Alfa = 0;

while((IsoConditionParser.Eval(Bprime) == 1) && (Alfa < 10)) {
Bprime[0] += DiffX;
Bprime[1] += DiffY;
Bprime[2] += DiffZ;
Alfa += 1;
}

///+++++++++++++++++++++++++///
/// Save theses points  and the triangles here
/// We have to new points to add

/// Add Aprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Aprime[0];
NormVertexTab[3+2*IndexPoint+1] = Aprime[1];
NormVertexTab[3+2*IndexPoint+2] = Aprime[2];

IndexAprime = NbPointIsoMap;
NbPointIsoMap++;

/// Add Bprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Bprime[0];
NormVertexTab[3+2*IndexPoint+1] = Bprime[1];
NormVertexTab[3+2*IndexPoint+2] = Bprime[2];
IndexBprime = NbPointIsoMap;
NbPointIsoMap++;

/// Add two new triangles :

///(Aprime, Bprime,C)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexThirdPoint;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

///(A, B, Bprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexBprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

///(A, Bprime, Aprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexAprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

///(Aprime, Bprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexBprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 4;
NbTriangleIsoSurface++;

///+++++++++++++++++++++++++///

} /// End of if(WichPointVeryCond[IndexThirdPoint] != 0)...
}/// End of if(WichPointVeryCond[IndexSeconPoint] == 0)
else {
/// Second case : A == 0; B != 0; C == 0;
  if(WichPointVeryCond[IndexThirdPoint] == 0){
/// Aprime
Aprime[0] = NormVertexTab[3+6*IndexSeconPoint  ];
Aprime[1] = NormVertexTab[3+6*IndexSeconPoint+1];
Aprime[2] = NormVertexTab[3+6*IndexSeconPoint+2];
DiffX = (NormVertexTab[3+6*IndexFirstPoint  ] - NormVertexTab[3+6*IndexSeconPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexFirstPoint+1] - NormVertexTab[3+6*IndexSeconPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexFirstPoint+2] - NormVertexTab[3+6*IndexSeconPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Aprime) == 1 && (Alfa < 10)) {
Aprime[0] += DiffX;
Aprime[1] += DiffY;
Aprime[2] += DiffZ;
//std::cout <<DiffX <<", X = "<< Aprime[0] <<"\n";
Alfa += 1;
}
/// Cprime
Cprime[0] = NormVertexTab[3+6*IndexSeconPoint  ];
Cprime[1] = NormVertexTab[3+6*IndexSeconPoint+1];
Cprime[2] = NormVertexTab[3+6*IndexSeconPoint+2];
DiffX = (NormVertexTab[3+6*IndexThirdPoint  ] - NormVertexTab[3+6*IndexSeconPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexThirdPoint+1] - NormVertexTab[3+6*IndexSeconPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexThirdPoint+2] - NormVertexTab[3+6*IndexSeconPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Cprime) == 1 && (Alfa < 10)) {
Cprime[0] += DiffX;
Cprime[1] += DiffY;
Cprime[2] += DiffZ;
Alfa += 1;
}

///+++++++++++++++++++++++++///
/// Save theses points  and the triangle here

/// Add Aprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Aprime[0];
NormVertexTab[3+2*IndexPoint+1] = Aprime[1];
NormVertexTab[3+2*IndexPoint+2] = Aprime[2];
NbPointIsoMap++;

/// Add Cprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Cprime[0];
NormVertexTab[3+2*IndexPoint+1] = Cprime[1];
NormVertexTab[3+2*IndexPoint+2] = Cprime[2];
NbPointIsoMap++;

/// Add Three new triangles :
IndexAprime = (NbPointIsoMap-2);
IndexCprime = (NbPointIsoMap-1);

///(Aprime, B, Cprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

/// (A , Aprime, Cprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

/// (A, Cprime, C)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexCprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexThirdPoint;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

/// (Aprime, Cprime) --> The border
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexCprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 4;
NbTriangleIsoSurface++;
}

/// Thid Case : : A == 0; B != 0; C != 0;
else {
/// Bprime
Bprime[0] = NormVertexTab[3+6*IndexSeconPoint  ];
Bprime[1] = NormVertexTab[3+6*IndexSeconPoint+1];
Bprime[2] = NormVertexTab[3+6*IndexSeconPoint+2];
DiffX = (NormVertexTab[3+6*IndexFirstPoint  ] - NormVertexTab[3+6*IndexSeconPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexFirstPoint+1] - NormVertexTab[3+6*IndexSeconPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexFirstPoint+2] - NormVertexTab[3+6*IndexSeconPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Bprime) == 1 && (Alfa < 10)) {
Bprime[0] += DiffX;
Bprime[1] += DiffY;
Bprime[2] += DiffZ;
Alfa += 1;
}

/// Cprime
Cprime[0] = NormVertexTab[3+6*IndexThirdPoint  ];
Cprime[1] = NormVertexTab[3+6*IndexThirdPoint+1];
Cprime[2] = NormVertexTab[3+6*IndexThirdPoint+2];
DiffX = (NormVertexTab[3+6*IndexFirstPoint  ] - NormVertexTab[3+6*IndexThirdPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexFirstPoint+1] - NormVertexTab[3+6*IndexThirdPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexFirstPoint+2] - NormVertexTab[3+6*IndexThirdPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Cprime) == 1 && (Alfa < 10)) {
Cprime[0] += DiffX;
Cprime[1] += DiffY;
Cprime[2] += DiffZ;
Alfa += 1;
}

/// Save theses points  and the triangle here

/// Add Bprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Bprime[0];
NormVertexTab[3+2*IndexPoint+1] = Bprime[1];
NormVertexTab[3+2*IndexPoint+2] = Bprime[2];
NbPointIsoMap++;

/// Add Cprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Cprime[0];
NormVertexTab[3+2*IndexPoint+1] = Cprime[1];
NormVertexTab[3+2*IndexPoint+2] = Cprime[2];
NbPointIsoMap++;

/// Add Three new triangles :
IndexBprime = (NbPointIsoMap-2);
IndexCprime = (NbPointIsoMap-1);

/// (A, Bprime, Cprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

/// (Bprime, B, C)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexThirdPoint;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

/// (Bprime, C, Cprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexThirdPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

/// (Bprime, Cprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexCprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 4;
NbTriangleIsoSurface++;
}
}
}
else {
/// Fourth Case : A != 0; B == 0, C == 0
if(WichPointVeryCond[IndexSeconPoint] == 0 && WichPointVeryCond[IndexThirdPoint] == 0) {

/// Bprime
Bprime[0] = NormVertexTab[3+6*IndexFirstPoint  ];
Bprime[1] = NormVertexTab[3+6*IndexFirstPoint+1];
Bprime[2] = NormVertexTab[3+6*IndexFirstPoint+2];
DiffX = (NormVertexTab[3+6*IndexSeconPoint  ] - NormVertexTab[3+6*IndexFirstPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexSeconPoint+1] - NormVertexTab[3+6*IndexFirstPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexSeconPoint+2] - NormVertexTab[3+6*IndexFirstPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Bprime) == 1 && (Alfa < 10)) {
Bprime[0] += DiffX;
Bprime[1] += DiffY;
Bprime[2] += DiffZ;
Alfa += 1;
}

/// Cprime
Cprime[0] = NormVertexTab[3+6*IndexFirstPoint  ];
Cprime[1] = NormVertexTab[3+6*IndexFirstPoint+1];
Cprime[2] = NormVertexTab[3+6*IndexFirstPoint+2];
DiffX = (NormVertexTab[3+6*IndexThirdPoint  ] - NormVertexTab[3+6*IndexFirstPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexThirdPoint+1] - NormVertexTab[3+6*IndexFirstPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexThirdPoint+2] - NormVertexTab[3+6*IndexFirstPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Cprime) == 1 && (Alfa < 10)) {
Cprime[0] += DiffX;
Cprime[1] += DiffY;
Cprime[2] += DiffZ;
Alfa += 1;
}

///+++++++++++++++++++++++++///
/// Save theses points  and the triangle here
/// Add Bprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Bprime[0];
NormVertexTab[3+2*IndexPoint+1] = Bprime[1];
NormVertexTab[3+2*IndexPoint+2] = Bprime[2];
NbPointIsoMap++;

/// Add Cprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Cprime[0];
NormVertexTab[3+2*IndexPoint+1] = Cprime[1];
NormVertexTab[3+2*IndexPoint+2] = Cprime[2];
NbPointIsoMap++;

/// Add Three new triangles :
IndexBprime = (NbPointIsoMap-2);
IndexCprime = (NbPointIsoMap-1);

/// (A, Bprime, Cprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

/// (Bprime, B, C)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexThirdPoint;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

/// (Bprime, C, Cprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexThirdPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

/// (Bprime, Cprime) --> the border
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexCprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 4; /// Type = 4-->Border
NbTriangleIsoSurface++;
///+++++++++++++++++++++++++///
}
/// Fifth Case : A != 0; B == 0, C != 0
/// We generate Two Triangles
else if (WichPointVeryCond[IndexSeconPoint] == 0 && WichPointVeryCond[IndexThirdPoint] != 0) {
/// Aprime :
Aprime[0] = NormVertexTab[3+6*IndexFirstPoint  ];
Aprime[1] = NormVertexTab[3+6*IndexFirstPoint+1];
Aprime[2] = NormVertexTab[3+6*IndexFirstPoint+2];
DiffX = (NormVertexTab[3+6*IndexSeconPoint  ] - NormVertexTab[3+6*IndexFirstPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexSeconPoint+1] - NormVertexTab[3+6*IndexFirstPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexSeconPoint+2] - NormVertexTab[3+6*IndexFirstPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Aprime) == 1 && (Alfa < 10)) {
Aprime[0] += DiffX;
Aprime[1] += DiffY;
Aprime[2] += DiffZ;
Alfa += 1;
}

/// Cprime
Cprime[0] = NormVertexTab[3+6*IndexThirdPoint  ];
Cprime[1] = NormVertexTab[3+6*IndexThirdPoint+1];
Cprime[2] = NormVertexTab[3+6*IndexThirdPoint+2];
DiffX = (NormVertexTab[3+6*IndexSeconPoint  ] - NormVertexTab[3+6*IndexThirdPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexSeconPoint+1] - NormVertexTab[3+6*IndexThirdPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexSeconPoint+2] - NormVertexTab[3+6*IndexThirdPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Cprime) == 1 && (Alfa < 10)) {
Cprime[0] += DiffX;
Cprime[1] += DiffY;
Cprime[2] += DiffZ;
Alfa += 1;
}

///+++++++++++++++++++++++++///
/// Save theses points  and the triangle here
/// Save theses points  and the triangle here
/// Add Aprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Aprime[0];
NormVertexTab[3+2*IndexPoint+1] = Aprime[1];
NormVertexTab[3+2*IndexPoint+2] = Aprime[2];
NbPointIsoMap++;

/// Add Cprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Cprime[0];
NormVertexTab[3+2*IndexPoint+1] = Cprime[1];
NormVertexTab[3+2*IndexPoint+2] = Cprime[2];
NbPointIsoMap++;

/// Add Three new triangles :
IndexAprime = (NbPointIsoMap-2);
IndexCprime = (NbPointIsoMap-1);

/// (B, Cprime, Aprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexSeconPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexCprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexAprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

/// (Aprime, Cprime, C)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexCprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexThirdPoint;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

/// (Aprime, C, A)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexThirdPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexFirstPoint;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

/// (Aprime, Cprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexCprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexCprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 4;
NbTriangleIsoSurface++;
}
/// Sixth Case : A != 0; B != 0, C == 0
/// We generate Two Triangles
else if (WichPointVeryCond[IndexSeconPoint] != 0 && WichPointVeryCond[IndexThirdPoint] == 0) {
/// Aprime
Aprime[0] = NormVertexTab[3+6*IndexFirstPoint  ];
Aprime[1] = NormVertexTab[3+6*IndexFirstPoint+1];
Aprime[2] = NormVertexTab[3+6*IndexFirstPoint+2];
DiffX = (NormVertexTab[3+6*IndexThirdPoint  ] - NormVertexTab[3+6*IndexFirstPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexThirdPoint+1] - NormVertexTab[3+6*IndexFirstPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexThirdPoint+2] - NormVertexTab[3+6*IndexFirstPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Aprime) == 1 && (Alfa < 10)) {
Aprime[0] += DiffX;
Aprime[1] += DiffY;
Aprime[2] += DiffZ;
Alfa += 1;
}

/// Bprime
Bprime[0] = NormVertexTab[3+6*IndexSeconPoint  ];
Bprime[1] = NormVertexTab[3+6*IndexSeconPoint+1];
Bprime[2] = NormVertexTab[3+6*IndexSeconPoint+2];
DiffX = (NormVertexTab[3+6*IndexThirdPoint  ] - NormVertexTab[3+6*IndexSeconPoint  ])/10;
DiffY = (NormVertexTab[3+6*IndexThirdPoint+1] - NormVertexTab[3+6*IndexSeconPoint+1])/10;
DiffZ = (NormVertexTab[3+6*IndexThirdPoint+2] - NormVertexTab[3+6*IndexSeconPoint+2])/10;
Alfa = 0;
while(IsoConditionParser.Eval(Bprime) == 1 && (Alfa < 10)) {
Bprime[0] += DiffX;
Bprime[1] += DiffY;
Bprime[2] += DiffZ;
Alfa += 1;
}

///+++++++++++++++++++++++++///
/// Save theses points  and the triangle here

/// Add Aprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Aprime[0];
NormVertexTab[3+2*IndexPoint+1] = Aprime[1];
NormVertexTab[3+2*IndexPoint+2] = Aprime[2];
NbPointIsoMap++;

/// Add Bprime
IndexPoint = 3*NbPointIsoMap;
NormVertexTab[3+2*IndexPoint  ] = Bprime[0];
NormVertexTab[3+2*IndexPoint+1] = Bprime[1];
NormVertexTab[3+2*IndexPoint+2] = Bprime[2];
NbPointIsoMap++;
/// Add Three new triangles :
IndexAprime = (NbPointIsoMap-2);
IndexBprime = (NbPointIsoMap-1);

/// (Aprime, Bprime, C)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexThirdPoint;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 0;
NbTriangleIsoSurface++;

/// (A, B, Bprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexSeconPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexBprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

/// (A, Bprime, Aprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexFirstPoint;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexAprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 1;
NbTriangleIsoSurface++;

/// (Aprime, Bprime)
IndexNbTriangle = NbTriangleIsoSurface*3;
IsoSurfaceTriangleListe[IndexNbTriangle  ] = IndexAprime;
IsoSurfaceTriangleListe[IndexNbTriangle+1] = IndexBprime;
IsoSurfaceTriangleListe[IndexNbTriangle+2] = IndexBprime;
TypeIsoSurfaceTriangleListeCND[NbTriangleIsoSurface] = 4;
NbTriangleIsoSurface++;
}}}/// End if if(IndexFirstPoint != -20...
}}}
}

///+++++++++++++++++++++++++++++++++++++++++
   void Iso3D::PointEdgeComputation(){
    int index, i_Start, i_End, j_Start, j_End, k_Start, k_End;
    double vals[7], IsoValue_1, IsoValue_2, rapport;
    double factor;

/// We have to compute the edges for the Grid limits ie: i=0, j=0 and k=0
NbPointIsoMap = 0;

i_Start = 1;
j_Start = 1;
k_Start = 1;

i_End = nb_ligne-1;
j_End = nb_colon-1;
k_End = nb_depth-1;
/// The code is doubled to eliminate conditions tests

     for(i = i_Start; i < i_End; i++){ I = i*maxgrscalemaxgr;
      for(j = j_Start; j < j_End; j++){ J = I + j*maximumgrid;
       for(k = k_Start; k < k_End; k++){
        IJK                 = J+k;
        IPLUSONEJK          = IJK + maxgrscalemaxgr;
        IMINUSONEJK         = IJK - maxgrscalemaxgr;
        IJPLUSONEK          = IJK + maximumgrid;
        IJMINUSONEK         = IJK - maximumgrid;
        IMINUSONEJMINUSONEK = IMINUSONEJK - maximumgrid;

        IsoValue_1 = Results[IJK];
/// First Case P(i+1)(j)(k)

        IsoValue_2 = Results[IPLUSONEJK];
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0 ) {

          // Edge Point computation and  save in IsoPointMap
          factor = (IsoValue - IsoValue_1)/rapport;
          index  = 2*NbPointIsoMap*3;

//vals[0] = GridVoxelVarPt[IJK].PositionX + factor * (GridVoxelVarPt[IPLUSONEJK].PositionX - GridVoxelVarPt[IJK].PositionX);
//vals[1] = GridVoxelVarPt[IJK].PositionY + factor * (GridVoxelVarPt[IPLUSONEJK].PositionY - GridVoxelVarPt[IJK].PositionY);
//vals[2] = GridVoxelVarPt[IJK].PositionZ + factor * (GridVoxelVarPt[IPLUSONEJK].PositionZ - GridVoxelVarPt[IJK].PositionZ);
vals[0] = XLocal[i] - factor * X_Step;
vals[1] = YLocal[j];
vals[2] = ZLocal[k];
///===========================================================///

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[IJK].Edge_Points[0] = NbPointIsoMap;
          GridVoxelVarPt[IJK].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
          GridVoxelVarPt[IJMINUSONEK].Edge_Points[4] = NbPointIsoMap;
          GridVoxelVarPt[IJMINUSONEK].NbEdgePoint += 1;

          GridVoxelVarPt[IJK-1].Edge_Points[2]   = NbPointIsoMap;
          GridVoxelVarPt[IJK-1].NbEdgePoint += 1;

          GridVoxelVarPt[IJMINUSONEK-1].Edge_Points[6] = NbPointIsoMap;
          GridVoxelVarPt[IJMINUSONEK-1].NbEdgePoint += 1;

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;
NbPointIsoMap++;
        }
///+++++++++++++++++++++++++++++++++++++++++
/// Second Case P(i)(j+1)(k)

        IsoValue_2 = Results[IJPLUSONEK];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;

//vals[0] = GridVoxelVarPt[IJK].PositionX + factor * (GridVoxelVarPt[IJPLUSONEK].PositionX - GridVoxelVarPt[IJK].PositionX);
//vals[1] = GridVoxelVarPt[IJK].PositionY + factor * (GridVoxelVarPt[IJPLUSONEK].PositionY - GridVoxelVarPt[IJK].PositionY);
//vals[2] = GridVoxelVarPt[IJK].PositionZ + factor * (GridVoxelVarPt[IJPLUSONEK].PositionZ - GridVoxelVarPt[IJK].PositionZ);
vals[0] = XLocal[i];
vals[1] = YLocal[j] - factor * Y_Step;
vals[2] = ZLocal[k];
NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[IJK].Edge_Points[8] = NbPointIsoMap;
          GridVoxelVarPt[IJK].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
          GridVoxelVarPt[IMINUSONEJK].Edge_Points[9]    = NbPointIsoMap;
          GridVoxelVarPt[IMINUSONEJK].NbEdgePoint += 1;

          GridVoxelVarPt[IJK-1].Edge_Points[11]   = NbPointIsoMap;
          GridVoxelVarPt[IJK-1].NbEdgePoint += 1;

          GridVoxelVarPt[IMINUSONEJK-1].Edge_Points[10] = NbPointIsoMap;
          GridVoxelVarPt[IMINUSONEJK-1].NbEdgePoint += 1;

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

NbPointIsoMap++;
}

// Third Case P(i)(j)(k+1)

        IsoValue_2 = Results[IJK+1];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;

//vals[0] = GridVoxelVarPt[IJK].PositionX + factor * (GridVoxelVarPt[IJK+1].PositionX - GridVoxelVarPt[IJK].PositionX);
//vals[1] = GridVoxelVarPt[IJK].PositionY + factor * (GridVoxelVarPt[IJK+1].PositionY - GridVoxelVarPt[IJK].PositionY);
//vals[2] = GridVoxelVarPt[IJK].PositionZ + factor * (GridVoxelVarPt[IJK+1].PositionZ - GridVoxelVarPt[IJK].PositionZ);
vals[0] = XLocal[i];
vals[1] = YLocal[j];
vals[2] = ZLocal[k] - factor * Z_Step;

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[IJK].Edge_Points[3] = NbPointIsoMap;
          GridVoxelVarPt[IJK].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
          GridVoxelVarPt[IMINUSONEJK].Edge_Points[1]   = NbPointIsoMap;
          GridVoxelVarPt[IMINUSONEJK].NbEdgePoint += 1;

          GridVoxelVarPt[IJMINUSONEK].Edge_Points[7]   = NbPointIsoMap;
          GridVoxelVarPt[IJMINUSONEK].NbEdgePoint += 1;

          GridVoxelVarPt[IMINUSONEJMINUSONEK].Edge_Points[5] = NbPointIsoMap;
          GridVoxelVarPt[IMINUSONEJMINUSONEK].NbEdgePoint += 1;

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

NbPointIsoMap++;
}
}}}

/// Now we have to compute the Grid's limits...
/// The code is quite big but this is much more easy to compute

/// 1) First case : i =0;

 i =0;
      for(j=0; j < nb_colon; j++){ J = j*maximumgrid;
       for(k=0; k < nb_depth; k++){ JK = J +k;

        IsoValue_1 = Results[JK];

// First Case P(1)(j)(k)

        IsoValue_2 = Results[maxgrscalemaxgr+JK];
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          // Edge Point computation and  save in IsoPointMap
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap*3;
/*
          vals[0] = GridVoxelVarPt[JK].PositionX + factor * (GridVoxelVarPt[maxgrscalemaxgr+JK].PositionX - GridVoxelVarPt[JK].PositionX);
          vals[1] = GridVoxelVarPt[JK].PositionY + factor * (GridVoxelVarPt[maxgrscalemaxgr+JK].PositionY - GridVoxelVarPt[JK].PositionY);
          vals[2] = GridVoxelVarPt[JK].PositionZ + factor * (GridVoxelVarPt[maxgrscalemaxgr+JK].PositionZ - GridVoxelVarPt[JK].PositionZ);
*/
vals[0] = XLocal[i] - factor * X_Step;
vals[1] = YLocal[j];
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[JK].Edge_Points[0] = NbPointIsoMap;
          GridVoxelVarPt[JK].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if( j != 0){
          GridVoxelVarPt[JK-maximumgrid].Edge_Points[4] = NbPointIsoMap;
          GridVoxelVarPt[JK-maximumgrid].NbEdgePoint += 1;
}
if ( k != 0 ) {
          GridVoxelVarPt[JK-1].Edge_Points[2]   = NbPointIsoMap;
          GridVoxelVarPt[JK-1].NbEdgePoint += 1;
}
if( j != 0 && k != 0) {
          GridVoxelVarPt[JK-maximumgrid-1].Edge_Points[6] = NbPointIsoMap;
          GridVoxelVarPt[JK-maximumgrid-1].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

 NbPointIsoMap++;
        }

// Second Case P(0)(j+1)(k)
if ( j != (nb_colon -1)){
        IsoValue_2 = Results[JK+maximumgrid];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[JK].PositionX + factor * (GridVoxelVarPt[JK+maximumgrid].PositionX - GridVoxelVarPt[JK].PositionX);
          vals[1] = GridVoxelVarPt[JK].PositionY + factor * (GridVoxelVarPt[JK+maximumgrid].PositionY - GridVoxelVarPt[JK].PositionY);
          vals[2] = GridVoxelVarPt[JK].PositionZ + factor * (GridVoxelVarPt[JK+maximumgrid].PositionZ - GridVoxelVarPt[JK].PositionZ);
*/
vals[0] = XLocal[i];
vals[1] = YLocal[j] - factor * Y_Step;
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[JK].Edge_Points[8] = NbPointIsoMap;
          GridVoxelVarPt[JK].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if ( k != 0){
          GridVoxelVarPt[JK-1].Edge_Points[11]   = NbPointIsoMap;
          GridVoxelVarPt[JK-1].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;
          NbPointIsoMap++;
        }
} /// If ( j != nb_colon -1) ...

// Third Case P(0)(j)(k+1)
if ( k != (nb_depth-1)){
        IsoValue_2 = Results[JK+1];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[JK].PositionX + factor * (GridVoxelVarPt[JK+1].PositionX - GridVoxelVarPt[JK].PositionX);
          vals[1] = GridVoxelVarPt[JK].PositionY + factor * (GridVoxelVarPt[JK+1].PositionY - GridVoxelVarPt[JK].PositionY);
          vals[2] = GridVoxelVarPt[JK].PositionZ + factor * (GridVoxelVarPt[JK+1].PositionZ - GridVoxelVarPt[JK].PositionZ);
*/
vals[0] = XLocal[i];
vals[1] = YLocal[j];
vals[2] = ZLocal[k] - factor * Z_Step;

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[JK].Edge_Points[3] = NbPointIsoMap;
          GridVoxelVarPt[JK].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if ( j != 0) {
          GridVoxelVarPt[JK-maximumgrid].Edge_Points[7]   = NbPointIsoMap;
          GridVoxelVarPt[JK-maximumgrid].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;


          NbPointIsoMap++;

        }
} /// End of ( if ( k != nb_depth -1)....
   }}







/// 2) Case i = nb_ligne-1

i = nb_ligne-1;
I = i*maxgrscalemaxgr;
      for(j=0; j < nb_colon; j++){ J = I + j*maximumgrid;
       for(k=0; k < nb_depth; k++){ JK = J + k;

        IsoValue_1 = Results[JK];


// Second Case P(i)(j+1)(k)
if ( j != (nb_colon -1)){
        IsoValue_2 = Results[JK+maximumgrid];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[JK].PositionX + factor * (GridVoxelVarPt[JK+maximumgrid].PositionX - GridVoxelVarPt[JK].PositionX);
          vals[1] = GridVoxelVarPt[JK].PositionY + factor * (GridVoxelVarPt[JK+maximumgrid].PositionY - GridVoxelVarPt[JK].PositionY);
          vals[2] = GridVoxelVarPt[JK].PositionZ + factor * (GridVoxelVarPt[JK+maximumgrid].PositionZ - GridVoxelVarPt[JK].PositionZ);
*/
vals[0] = XLocal[i];
vals[1] = YLocal[j] - factor * Y_Step;
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[JK].Edge_Points[8] = NbPointIsoMap;
          GridVoxelVarPt[JK].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if(i != 0){
          GridVoxelVarPt[JK-maxgrscalemaxgr].Edge_Points[9]    = NbPointIsoMap;
          GridVoxelVarPt[JK-maxgrscalemaxgr].NbEdgePoint += 1;
}
if(k != 0){
          GridVoxelVarPt[JK-1].Edge_Points[11]   = NbPointIsoMap;
          GridVoxelVarPt[JK-1].NbEdgePoint += 1;
}
if(i != 0 && k != 0){
          GridVoxelVarPt[JK-maxgrscalemaxgr-1].Edge_Points[10] = NbPointIsoMap;
          GridVoxelVarPt[JK-maxgrscalemaxgr-1].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

          NbPointIsoMap++;

        }
} /// End of if (j != nb_colon -1)...

// Third Case P(i)(j)(k+1)
if ( k != (nb_depth -1)){
        IsoValue_2 = Results[JK+1];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[JK].PositionX + factor * (GridVoxelVarPt[JK+1].PositionX - GridVoxelVarPt[JK].PositionX);
          vals[1] = GridVoxelVarPt[JK].PositionY + factor * (GridVoxelVarPt[JK+1].PositionY - GridVoxelVarPt[JK].PositionY);
          vals[2] = GridVoxelVarPt[JK].PositionZ + factor * (GridVoxelVarPt[JK+1].PositionZ - GridVoxelVarPt[JK].PositionZ);
*/
vals[0] = XLocal[i];
vals[1] = YLocal[j];
vals[2] = ZLocal[k] - factor * Z_Step;

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[JK].Edge_Points[3] = NbPointIsoMap;
          GridVoxelVarPt[JK].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if( i != 0) {
          GridVoxelVarPt[JK-maxgrscalemaxgr].Edge_Points[1]   = NbPointIsoMap;
          GridVoxelVarPt[JK-maxgrscalemaxgr].NbEdgePoint += 1;
}
if(j != 0) {
          GridVoxelVarPt[JK-maximumgrid].Edge_Points[7]   = NbPointIsoMap;
          GridVoxelVarPt[JK-maximumgrid].NbEdgePoint += 1;
}
if( i !=0 && j != 0) {
          GridVoxelVarPt[JK-maxgrscalemaxgr-maximumgrid].Edge_Points[5] = NbPointIsoMap;
          GridVoxelVarPt[JK-maxgrscalemaxgr-maximumgrid].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

          NbPointIsoMap++;

        }
} /// End of if ( k != nb_depth -1)...
     }}



/// 3) Case j = 0
j= 0;

     for(i=0; i < nb_ligne; i++)
       for(k=0; k < nb_depth; k++)
 {

        IsoValue_1 = Results[i*maxgrscalemaxgr+k];

// First Case P(i+1)(j)(k)
if( i != (nb_ligne -1)){
        IsoValue_2 = Results[(i+1)*maxgrscalemaxgr+k];
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {

          // Edge Point computation and  save in IsoPointMap
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionX + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+k].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionX);
vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionY + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+k].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionY);
vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionZ + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+k].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionZ);
*/
vals[0] = XLocal[i] - factor * X_Step;
vals[1] = YLocal[j];
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+k].Edge_Points[0] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+k].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if( k!=0){
          GridVoxelVarPt[i*maxgrscalemaxgr+k-1].Edge_Points[2]   = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+k-1].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

          NbPointIsoMap++;
        }
} /// End of if ( i != nb_ligne -1)...

// Second Case P(i)(j+1)(k)

        IsoValue_2 = Results[i*maxgrscalemaxgr+maximumgrid+k];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionX + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+maximumgrid+k].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionX);
vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionY + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+maximumgrid+k].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionY);
vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionZ + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+maximumgrid+k].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionZ);
*/
vals[0] = XLocal[i];
vals[1] = YLocal[j] - factor * Y_Step;
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+k].Edge_Points[8] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+k].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if( i !=0 ){
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+k].Edge_Points[9]    = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+k].NbEdgePoint += 1;
}
if(k !=0){
          GridVoxelVarPt[i*maxgrscalemaxgr+k-1].Edge_Points[11]   = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+k-1].NbEdgePoint += 1;
}
if( i !=0 && k !=0){
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+k-1].Edge_Points[10] = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+k-1].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

          NbPointIsoMap++;

        }


// Third Case P(i)(j)(k+1)
if(k != (nb_depth -1)){
        IsoValue_2 = Results[i*maxgrscalemaxgr+k+1];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionX + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+k+1].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionX);
vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionY + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+k+1].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionY);
vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionZ + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+k+1].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+k].PositionZ);
*/
vals[0] = XLocal[i];
vals[1] = YLocal[j];
vals[2] = ZLocal[k] - factor * Z_Step;

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+k].Edge_Points[3] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+k].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if( i != 0) {
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+k].Edge_Points[1]   = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+k].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

          NbPointIsoMap++;

        }
} /// End of if(k != (nb_depth -1))...
     }







/// 4) Case j = nb_colon -1
j = nb_colon-1;

     for(i=0; i < nb_ligne; i++)
       for(k=0; k < nb_depth; k++)
 {

        IsoValue_1 = Results[i*maxgrscalemaxgr+j*maximumgrid+k];


// First Case P(i+1)(j)(k)
if( i != (nb_ligne-1)) {
        IsoValue_2 = Results[(i+1)*maxgrscalemaxgr+j*maximumgrid+k];
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {

          // Edge Point computation and  save in IsoPointMap
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionX + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid+k].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionX);
vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionY + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid+k].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionY);
vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionZ + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid+k].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionZ);
*/
vals[0] = XLocal[i] - factor * X_Step;
vals[1] = YLocal[j];
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].Edge_Points[0] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if( j != 0){
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k].Edge_Points[4] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k].NbEdgePoint += 1;
}
if(k != 0){
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k-1].Edge_Points[2]   = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k-1].NbEdgePoint += 1;
}
if(j != 0 && k != 0) {
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k-1].Edge_Points[6] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k-1].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;

          NbPointIsoMap++;


        }
} /// End of if( i != (nb_ligne-1))...

// Third Case P(i)(j)(k+1)
if( k != (nb_depth -1)){
        IsoValue_2 = Results[i*maxgrscalemaxgr+j*maximumgrid+k+1];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionX + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k+1].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionX);

vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionY + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k+1].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionY);

vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionZ + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k+1].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionZ);

*/
vals[0] = XLocal[i];
vals[1] = YLocal[j];
vals[2] = ZLocal[k] - factor * Z_Step;

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].Edge_Points[3] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if(i !=0){
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid+k].Edge_Points[1]   = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid+k].NbEdgePoint += 1;
}
if( j!=0){
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k].Edge_Points[7]   = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k].NbEdgePoint += 1;
}
if(i != 0 && j !=0){
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+(j-1)*maximumgrid+k].Edge_Points[5] = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+(j-1)*maximumgrid+k].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;
          NbPointIsoMap++;

        }
     } /// End of if (k != nb_depth)...
}





/// 5) Case k = 0

k =0;

     for(i=0; i < nb_ligne; i++)
      for(j=0; j < nb_colon; j++)
 {
        IsoValue_1 = Results[i*maxgrscalemaxgr+j*maximumgrid];
// First Case P(i+1)(j)(k)
if(i != (nb_ligne -1)){
        IsoValue_2 = Results[(i+1)*maxgrscalemaxgr+j*maximumgrid];
        if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          // Edge Point computation and  save in IsoPointMap
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionX + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionX);

          vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionY + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionY);

          vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionZ + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionZ);

*/
vals[0] = XLocal[i] - factor * X_Step;
vals[1] = YLocal[j];
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].Edge_Points[0] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].NbEdgePoint += 1;

          // The same Point is used in one other Voxel
 if(j !=0){         GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid].Edge_Points[4] = NbPointIsoMap;
                    GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;
          NbPointIsoMap++;


        }
} /// End of if(i != (nb_ligne -1))

// Second Case P(i)(j+1)(k)
if(j != nb_colon -1) {
        IsoValue_2 = Results[i*maxgrscalemaxgr+(j+1)*maximumgrid];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionX + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+(j+1)*maximumgrid].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionX);

          vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionY + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+(j+1)*maximumgrid].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionY);

          vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionZ + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+(j+1)*maximumgrid].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionZ);
*/

vals[0] = XLocal[i];
vals[1] = YLocal[j] - factor * Y_Step;
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].Edge_Points[8] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].NbEdgePoint += 1;

          // The same Point is used in one other Voxels
if ( i !=0 ) {
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid].Edge_Points[9]    = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;
          NbPointIsoMap++;

        }
}/// End of if(j != nb_colon -1)...

// Third Case P(i)(j)(k+1)

        IsoValue_2 = Results[i*maxgrscalemaxgr+j*maximumgrid+1];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionX + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+1].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionX);

          vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionY + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+1].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionY);

          vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionZ + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+1].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].PositionZ);
*/

vals[0] = XLocal[i];
vals[1] = YLocal[j];
vals[2] = ZLocal[k] - factor * Z_Step;

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].Edge_Points[3] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if ( i !=0 ) {
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid].Edge_Points[1]   = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid].NbEdgePoint += 1;
}
if (j != 0 ) {
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid].Edge_Points[7]   = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid].NbEdgePoint += 1;
}
if ( i !=0 && j != 0 ) {
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+(j-1)*maximumgrid].Edge_Points[5] = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+(j-1)*maximumgrid].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;
          NbPointIsoMap++;

        }
     }




/// 6) Case k = nb_depth -1

k = nb_depth -1;

     for(i=0; i < nb_ligne; i++)
      for(j=0; j < nb_colon; j++)
 {

        IsoValue_1 = Results[i*maxgrscalemaxgr+j*maximumgrid+k];


// First Case P(i+1)(j)(k)
if( i != (nb_ligne -1) ){
        IsoValue_2 = Results[(i+1)*maxgrscalemaxgr+j*maximumgrid+k];
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {

          // Edge Point computation and  save in IsoPointMap
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionX + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid+k].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionX);

          vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionY + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid+k].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionY);

          vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionZ + factor * (GridVoxelVarPt[(i+1)*maxgrscalemaxgr+j*maximumgrid+k].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionZ);
*/
vals[0] = XLocal[i] - factor * X_Step;
vals[1] = YLocal[j];
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].Edge_Points[0] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if(j !=0) {
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k].Edge_Points[4] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k].NbEdgePoint += 1;
}
if(k !=0){
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k-1].Edge_Points[2]   = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k-1].NbEdgePoint += 1;
}
if(j !=0 && k != 0) {
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k-1].Edge_Points[6] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+(j-1)*maximumgrid+k-1].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;
          NbPointIsoMap++;


        }
} /// End of if(i != nb_ligne-1)...

// Second Case P(i)(j+1)(k)
if( j != (nb_colon -1) ){
        IsoValue_2 = Results[i*maxgrscalemaxgr+(j+1)*maximumgrid+k];
          // Edge Point computation and  save in IsoPointMap
         if(IsoValue_1 * IsoValue_2 <= 0 && (rapport=IsoValue_2 - IsoValue_1)!=0) {
          factor = (IsoValue - IsoValue_1)/rapport;
          index = 2*NbPointIsoMap *3;
/*
          vals[0] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionX + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+(j+1)*maximumgrid+k].PositionX - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionX);

          vals[1] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionY + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+(j+1)*maximumgrid+k].PositionY - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionY);

          vals[2] = GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionZ + factor * (GridVoxelVarPt[i*maxgrscalemaxgr+(j+1)*maximumgrid+k].PositionZ - GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].PositionZ);
*/
vals[0] = XLocal[i];
vals[1] = YLocal[j] - factor * Y_Step;
vals[2] = ZLocal[k];

NormVertexTab[3+SixTimesNbVertexTmp+index  ] = vals[0];
NormVertexTab[3+SixTimesNbVertexTmp+index+1] = vals[1];
NormVertexTab[3+SixTimesNbVertexTmp+index+2] = vals[2];

          // save The reference to this point
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].Edge_Points[8] = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k].NbEdgePoint += 1;

          // The same Point is used in three other Voxels
if( i !=0 ){
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid+k].Edge_Points[9]    = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid+k].NbEdgePoint += 1;
}
if( k !=0 ){
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k-1].Edge_Points[11]   = NbPointIsoMap;
          GridVoxelVarPt[i*maxgrscalemaxgr+j*maximumgrid+k-1].NbEdgePoint += 1;
}
if( i !=0 && k !=0 ){
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid+k-1].Edge_Points[10] = NbPointIsoMap;
          GridVoxelVarPt[(i-1)*maxgrscalemaxgr+j*maximumgrid+k-1].NbEdgePoint += 1;
}

if (IsoConditionRequired != 1) WichPointVeryCond[NbPointIsoMap] = 1;
else (IsoConditionParser.Eval(vals) == 1) ? WichPointVeryCond[NbPointIsoMap] = 1 : WichPointVeryCond[NbPointIsoMap] = 0;
          NbPointIsoMap++;

        }
} /// End of if( j != (nb_colon -1) )...



     }

///+++++++++ Here we have to take care of the imposed condition++++///




/// We generate the points af the 3D axes by using the limits of the Cube.
/// Axes are centered on the original point O(0,0,0):
double stepx, stepy, stepz, center_x, center_y, center_z;;
int ThreeTimesI;
if(DrawAxe_Ok == 1) {




MINX = 999999999;
MINY = 999999999;
MINZ = 999999999;

MAXX =-999999999;
MAXY =-999999999;
MAXZ =-999999999;

 for (i=0; i < NbPointIsoMap   ; i++){
 ThreeTimesI = 2*3*i;
          if(MINX > NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI  ] ) MINX = NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI  ] ;

     else if(MINY > NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI+1] ) MINY = NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI+1] ;

     else if(MINZ > NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI+2] ) MINZ = NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI+2] ;

     else if(MAXX < NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI  ] ) MAXX = NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI  ] ;

     else if(MAXY < NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI+1] ) MAXY = NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI+1] ;

     else if(MAXZ < NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI+2] ) MAXZ = NormVertexTab[3+SixTimesNbVertexTmp+ThreeTimesI+2] ;
                                  }


  DIFX = MAXX - MINX ;
  DIFY = MAXY - MINY ;
  DIFZ = MAXZ - MINZ ;







stepx = (2./3.)*DIFX*axe_size/40.;
stepy = (2./3.)*DIFY*axe_size/40.;
stepz = (2./3.)*DIFZ*axe_size/40.;

if(axe_center == -1) {
 center_x = (MAXX + MINX)/2.;
 center_y = (MAXY + MINY)/2.;
 center_z = (MAXZ + MINZ)/2.;
}
else center_x = center_y = center_z = 0;


for(i = 0; i <40; i++) {
ThreeTimesI = 3*i;
AxeArrayOriginal[0][ThreeTimesI  ] = i*stepx + center_x;
AxeArrayOriginal[0][ThreeTimesI+1] = center_y;
AxeArrayOriginal[0][ThreeTimesI+2] = center_z;

AxeArrayOriginal[1][ThreeTimesI  ] = center_x;
AxeArrayOriginal[1][ThreeTimesI+1] = i*stepy + center_y;
AxeArrayOriginal[1][ThreeTimesI+2] = center_z;

AxeArrayOriginal[2][ThreeTimesI  ] = center_x;
AxeArrayOriginal[2][ThreeTimesI+1] = center_y;
AxeArrayOriginal[2][ThreeTimesI+2] = i*stepz + center_z;
}


/// Here we add two points in every axe for the drawing of the arrow...

///X Axe :
AxeArrayOriginal[0][40*3  ] = AxeArrayOriginal[0][38*3  ];
AxeArrayOriginal[0][40*3+1] = AxeArrayOriginal[0][38*3+1] + 2*stepy ;
AxeArrayOriginal[0][40*3+2] = AxeArrayOriginal[0][38*3+2];

AxeArrayOriginal[0][41*3  ] = AxeArrayOriginal[0][38*3  ];
AxeArrayOriginal[0][41*3+1] = AxeArrayOriginal[0][38*3+1] - 2*stepy ;
AxeArrayOriginal[0][41*3+2] = AxeArrayOriginal[0][38*3+2];

///Y Axe :
AxeArrayOriginal[1][40*3  ] = AxeArrayOriginal[1][38*3  ] + 2*stepx;
AxeArrayOriginal[1][40*3+1] = AxeArrayOriginal[1][38*3+1];
AxeArrayOriginal[1][40*3+2] = AxeArrayOriginal[1][38*3+2];

AxeArrayOriginal[1][41*3  ] = AxeArrayOriginal[1][38*3  ] - 2*stepx;
AxeArrayOriginal[1][41*3+1] = AxeArrayOriginal[1][38*3+1];
AxeArrayOriginal[1][41*3+2] = AxeArrayOriginal[1][38*3+2];
///Z Axe :
AxeArrayOriginal[2][40*3  ] = AxeArrayOriginal[2][38*3  ] + 2*stepx;
AxeArrayOriginal[2][40*3+1] = AxeArrayOriginal[2][38*3+1];
AxeArrayOriginal[2][40*3+2] = AxeArrayOriginal[2][38*3+2];

AxeArrayOriginal[2][41*3  ] = AxeArrayOriginal[2][38*3  ] - 2*stepx;
AxeArrayOriginal[2][41*3+1] = AxeArrayOriginal[2][38*3+1];
AxeArrayOriginal[2][41*3+2] = AxeArrayOriginal[2][38*3+2];


} /// End of if(DrawAxe_Ok == 1)...



///+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///+++++++++++++++++++ Normals Calculation : +++++++++++++++++++++///



   };


///+++++++++++++++++++++++++++++++++++++++++++++++++++++///
   void Iso3D::SignatureComputation(){

     for(i=0; i < nb_ligne; i++){ I = i*maxgrscalemaxgr;
      for(j=0; j < nb_colon; j++){ J = I + j*maximumgrid;
       for(k=0; k < nb_depth; k++){
          IJK               = J + k;
		  IPLUSONEJK        = IJK + maxgrscalemaxgr;
		  IJPLUSONEK        = IJK + maximumgrid;
		  IPLUSONEJPLUSONEK = IPLUSONEJK + maximumgrid;

if(Results[IJK] <= 0) GridVoxelVarPt[IJK].Signature +=1;

if(i != (nb_ligne-1))
if(Results[IPLUSONEJK] <= 0) GridVoxelVarPt[IJK].Signature +=2;

if(i != (nb_ligne-1) && k != (nb_depth-1))
if(Results[IPLUSONEJK+1] <= 0) GridVoxelVarPt[IJK].Signature +=4;

if(k != (nb_depth-1))
if(Results[IJK+1] <= 0) GridVoxelVarPt[IJK].Signature +=8;

if(j != (nb_colon-1))
if(Results[IJPLUSONEK] <= 0) GridVoxelVarPt[IJK].Signature +=16;

if(i != (nb_ligne-1) && j != (nb_colon-1))
if(Results[IPLUSONEJPLUSONEK] <= 0) GridVoxelVarPt[IJK].Signature +=32;

if(i != (nb_ligne-1) && j != (nb_colon-1) && k != (nb_depth-1))
if(Results[IPLUSONEJPLUSONEK+1] <= 0) GridVoxelVarPt[IJK].Signature +=64;

if(j != (nb_colon-1) && k != (nb_depth-1))
if(Results[IJPLUSONEK+1] <= 0) GridVoxelVarPt[IJK].Signature +=128;
        } } }// End if(Grid...
   }

///++++++++++++++++++++ OutPut The IsoSurface +++++++++++++++++++++++
   void Iso3D::SaveIsoMap() {
     int IndexFirstPoint, IndexSecondPoint,
	     IndexThirdPoint, ThreeTimesI, ValIndex;
     double z_tmp, scalar;

   for (i=0; i < NbPointIsoMap ; i++){
        ThreeTimesI = 3*i;
        IsoNormOriginal[ThreeTimesI  ] = 0;
        IsoNormOriginal[ThreeTimesI+1] = 0;
        IsoNormOriginal[ThreeTimesI+2] = 0;
}

for(i = 0; i<NbTriangleIsoSurface; ++i) {
 ThreeTimesI   = i*3;
IndexFirstPoint  = 3*IsoSurfaceTriangleListe[ThreeTimesI  ];
IndexSecondPoint = 3*IsoSurfaceTriangleListe[ThreeTimesI+1];
IndexThirdPoint  = 3*IsoSurfaceTriangleListe[ThreeTimesI+2];

IsoNormOriginal[IndexFirstPoint  ] += NormOriginal[ThreeTimesI  ];
IsoNormOriginal[IndexFirstPoint+1] += NormOriginal[ThreeTimesI+1];
IsoNormOriginal[IndexFirstPoint+2] += NormOriginal[ThreeTimesI+2];

IsoNormOriginal[IndexSecondPoint  ] += NormOriginal[ThreeTimesI  ];
IsoNormOriginal[IndexSecondPoint+1] += NormOriginal[ThreeTimesI+1];
IsoNormOriginal[IndexSecondPoint+2] += NormOriginal[ThreeTimesI+2];

IsoNormOriginal[IndexThirdPoint  ] += NormOriginal[ThreeTimesI  ];
IsoNormOriginal[IndexThirdPoint+1] += NormOriginal[ThreeTimesI+1];
IsoNormOriginal[IndexThirdPoint+2] += NormOriginal[ThreeTimesI+2];
}

/// Normalisation of theses resulting normales
 for (i=0; i < NbPointIsoMap   ; i++){
 ThreeTimesI = 3*i;

scalar = (double)sqrt((IsoNormOriginal[ThreeTimesI  ]*IsoNormOriginal[ThreeTimesI  ]) +
                      (IsoNormOriginal[ThreeTimesI+1]*IsoNormOriginal[ThreeTimesI+1]) +
                      (IsoNormOriginal[ThreeTimesI+2]*IsoNormOriginal[ThreeTimesI+2]));

if(scalar < 0.000000001)  scalar  = 0.000000001;
IsoNormOriginal[ThreeTimesI  ] /= scalar;
IsoNormOriginal[ThreeTimesI+1] /= scalar;
IsoNormOriginal[ThreeTimesI+2] /= scalar;
}

NbTriangleUsed = 0;
for ( i=0; i < NbTriangleIsoSurface ; ++i) {

ThreeTimesI = 3*i;
IndexFirstPoint  = 3*IsoSurfaceTriangleListe[ThreeTimesI  ];
IndexSecondPoint = 3*IsoSurfaceTriangleListe[ThreeTimesI+1];
IndexThirdPoint  = 3*IsoSurfaceTriangleListe[ThreeTimesI+2];

z_tmp = (IsoPointMapTransfrm[IndexFirstPoint +2]+
         IsoPointMapTransfrm[IndexSecondPoint+2]+
         IsoPointMapTransfrm[IndexThirdPoint +2])/3;
if(z_tmp < 460 )
{
ValIndex = 18*NbTriangleUsed;
/// Save the 3 point of the vector
 FileOutput[ValIndex  ] = IsoPointMapTransfrm[IndexFirstPoint  ];
 FileOutput[ValIndex+1] = IsoPointMapTransfrm[IndexFirstPoint+1];
 FileOutput[ValIndex+2] = IsoPointMapTransfrm[IndexFirstPoint+2];

 FileOutput[ValIndex+3] = IsoPointMapTransfrm[IndexSecondPoint  ];
 FileOutput[ValIndex+4] = IsoPointMapTransfrm[IndexSecondPoint+1];
 FileOutput[ValIndex+5] = IsoPointMapTransfrm[IndexSecondPoint+2];

 FileOutput[ValIndex+6] = IsoPointMapTransfrm[IndexThirdPoint  ];
 FileOutput[ValIndex+7] = IsoPointMapTransfrm[IndexThirdPoint+1];
 FileOutput[ValIndex+8] = IsoPointMapTransfrm[IndexThirdPoint+2];

/// Save the normal vector
 FileOutput[ValIndex+9 ] = -IsoNormOriginal[IndexFirstPoint  ];
 FileOutput[ValIndex+10] = -IsoNormOriginal[IndexFirstPoint+1];
 FileOutput[ValIndex+11] = -IsoNormOriginal[IndexFirstPoint+2];

 FileOutput[ValIndex+12] = -IsoNormOriginal[IndexSecondPoint  ];
 FileOutput[ValIndex+13] = -IsoNormOriginal[IndexSecondPoint+1];
 FileOutput[ValIndex+14] = -IsoNormOriginal[IndexSecondPoint+2];

 FileOutput[ValIndex+15] = -IsoNormOriginal[IndexThirdPoint  ];
 FileOutput[ValIndex+16] = -IsoNormOriginal[IndexThirdPoint+1];
 FileOutput[ValIndex+17] = -IsoNormOriginal[IndexThirdPoint+2];

NbTriangleUsed++;

}
}
}

///++++++++++++++++++++ OutPut The IsoSurface +++++++++++++++++++++++
   void Iso3D::SaveIsoMapUnifColor() {
/*
     int ThreeTimesI;
     double pt1_x, pt1_y, pt1_z,
            pt2_x, pt2_y, pt2_z,
            XStep, YStep, ZStep,
            tp1, tp2, tp3,
            X_Val, Y_Val, Z_Val, ray;
     double vals[3];


     XStep = fabs((X_Start - X_End)/(maximumgrid*(nb_ligne-1)));
     YStep = fabs((Y_Start - Y_End)/(maximumgrid*(nb_colon-1)));
     ZStep = fabs((Z_Start - Z_End)/(maximumgrid*(nb_depth-1)));


   for (i=0; i < NbPointIsoMap ; i++){
        ThreeTimesI = 3*i;

/// Normal at this Point :

        X_Val = IsoPointMapOriginal[ThreeTimesI  ];
        Y_Val = IsoPointMapOriginal[ThreeTimesI+1];
        Z_Val = IsoPointMapOriginal[ThreeTimesI+2];

        vals[0] = X_Val + XStep;
        vals[1] = Y_Val;
        vals[2] = Z_Val;
        pt1_x = ImplicitFunctionParser.Eval(vals);
        vals[0] = X_Val - XStep;
        pt2_x = ImplicitFunctionParser.Eval(vals);
IsoNormTransfrm[ThreeTimesI  ] = pt1_x - pt2_x;

        vals[0] = X_Val;
        vals[1] = Y_Val + YStep;
        vals[2] = Z_Val;
        pt1_y = ImplicitFunctionParser.Eval(vals);
        vals[1] = Y_Val - YStep;
        pt2_y = ImplicitFunctionParser.Eval(vals);
IsoNormTransfrm[ThreeTimesI+1] = pt1_y - pt2_y;

        vals[0] = X_Val;
        vals[1] = Y_Val;
        vals[2] = Z_Val + ZStep;
        pt1_z = ImplicitFunctionParser.Eval(vals);
        vals[2] = Z_Val - ZStep;
        pt2_z = ImplicitFunctionParser.Eval(vals);
IsoNormTransfrm[ThreeTimesI+2] = pt1_z - pt2_z;

ray = sqrt(IsoNormTransfrm[ThreeTimesI  ]*IsoNormTransfrm[ThreeTimesI  ] +
      IsoNormTransfrm[ThreeTimesI+1]*IsoNormTransfrm[ThreeTimesI+1] +
      IsoNormTransfrm[ThreeTimesI+2]*IsoNormTransfrm[ThreeTimesI+2]);

IsoNormTransfrm[ThreeTimesI  ] /= ray;
IsoNormTransfrm[ThreeTimesI+1] /= ray;
IsoNormTransfrm[ThreeTimesI+2] /= ray;
}




///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++///
/// Now, we transform the Normal vectors :

   for (i=0; i < NbPointIsoMap ; i++){
        ThreeTimesI = 3*i;
        tp1 = IsoNormTransfrm[ThreeTimesI    ];
        tp2 = IsoNormTransfrm[ThreeTimesI + 1];
        tp3 = IsoNormTransfrm[ThreeTimesI + 2];
IsoNormOriginal[ThreeTimesI  ] = MatRotSave.xx*tp1 + MatRotSave.xy*tp2 +MatRotSave.xz*tp3 + MatRotSave.xo;
IsoNormOriginal[ThreeTimesI+1] = MatRotSave.yx*tp1 + MatRotSave.yy*tp2 +MatRotSave.yz*tp3 + MatRotSave.yo;
IsoNormOriginal[ThreeTimesI+2] = MatRotSave.zx*tp1 + MatRotSave.zy*tp2 +MatRotSave.zz*tp3 + MatRotSave.zo;
                                      }
*/
}

///++++++++++++++++++++ Draw The IsoSurface +++++++++++++++++++++++

void Iso3D::DrawIsoMap(QPainter & g) {
     int CurrentTriangle, tmp, nb_triangle, ThreeTimesI /*, TriangleIndex*/;
     double VectorScalar, cosinus, z_tmp, coefficient;
     vector<IsoTriangle *>::iterator itVectorData;
    int IndexFirstPoint, IndexSecondPoint, IndexThirdPoint;


/// memory reservation for 10.000 IsoTriangles
VectorIsoTriangle.reserve(maxgrscalemaxgr);


/// Projection of the Iso Surface :

    for ( i=0; i < NbPointIsoMap; ++i) {

ThreeTimesI = 3*i;

coefficient = D/(IsoPointMapTransfrm[ThreeTimesI + 2]-Oprime[2]);
IsoPointMapProjectd[ThreeTimesI  ] = coefficient*IsoPointMapTransfrm[ThreeTimesI  ]  + demi_hauteur;
IsoPointMapProjectd[ThreeTimesI+1] = coefficient*IsoPointMapTransfrm[ThreeTimesI+1]  + demi_largeur;
IsoPointMapProjectd[ThreeTimesI+2] = IsoPointMapTransfrm[ThreeTimesI+2];
                                        }

///+++++++++++++++++++++++++++++ New Stuff for Axes ++++++++++++++++++++++++++++///
/// Projection of the Iso Axes :
    for ( i=0; i < 42; ++i) {
ThreeTimesI = 3*i;

/// X Axe :
coefficient = D/(AxeArrayTransfrm[0][ThreeTimesI + 2]-Oprime[2]);
AxeArrayProjectd[0][ThreeTimesI  ] = coefficient*AxeArrayTransfrm[0][ThreeTimesI  ]  + demi_hauteur;
AxeArrayProjectd[0][ThreeTimesI+1] = coefficient*AxeArrayTransfrm[0][ThreeTimesI+1]  + demi_largeur;
AxeArrayProjectd[0][ThreeTimesI+2] =             AxeArrayTransfrm[0][ThreeTimesI+2];

/// y Axe :
coefficient = D/(AxeArrayTransfrm[1][ThreeTimesI + 2]-Oprime[2]);
AxeArrayProjectd[1][ThreeTimesI  ] = coefficient*AxeArrayTransfrm[1][ThreeTimesI  ]  + demi_hauteur;
AxeArrayProjectd[1][ThreeTimesI+1] = coefficient*AxeArrayTransfrm[1][ThreeTimesI+1]  + demi_largeur;
AxeArrayProjectd[1][ThreeTimesI+2] =             AxeArrayTransfrm[1][ThreeTimesI+2];

/// Z Axe :
coefficient = D/(AxeArrayTransfrm[2][ThreeTimesI + 2]-Oprime[2]);
AxeArrayProjectd[2][ThreeTimesI  ] = coefficient*AxeArrayTransfrm[2][ThreeTimesI  ]  + demi_hauteur;
AxeArrayProjectd[2][ThreeTimesI+1] = coefficient*AxeArrayTransfrm[2][ThreeTimesI+1]  + demi_largeur;
AxeArrayProjectd[2][ThreeTimesI+2] =             AxeArrayTransfrm[2][ThreeTimesI+2];

                                        }
///+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++///


/// Claculation of the Cosinus

NbTriangleUsed = 0;
for ( i=0; i < NbTriangleIsoSurface ; ++i) {

ThreeTimesI = 3*i;
IndexFirstPoint  = 3*IsoSurfaceTriangleListe[ThreeTimesI  ];
IndexSecondPoint = 3*IsoSurfaceTriangleListe[ThreeTimesI+1];
IndexThirdPoint  = 3*IsoSurfaceTriangleListe[ThreeTimesI+2];

z_tmp = (IsoPointMapTransfrm[IndexFirstPoint +2]+
         IsoPointMapTransfrm[IndexSecondPoint+2]+
         IsoPointMapTransfrm[IndexThirdPoint +2])/3;
if(z_tmp < 460 )
{

VectorScalar = (double)sqrt(
(Oprime[0]- IsoPointMapTransfrm[IndexFirstPoint  ])*
(Oprime[0]- IsoPointMapTransfrm[IndexFirstPoint  ]) +
(Oprime[1]- IsoPointMapTransfrm[IndexFirstPoint+1])*
(Oprime[1]- IsoPointMapTransfrm[IndexFirstPoint+1]) +
(Oprime[2]- IsoPointMapTransfrm[IndexFirstPoint+2])*
(Oprime[2]- IsoPointMapTransfrm[IndexFirstPoint+2]));

/// reduce the normals to the Unit vector

Obser[0]=(Oprime[0]-IsoPointMapTransfrm[IndexFirstPoint  ])/VectorScalar;
Obser[1]=(Oprime[1]-IsoPointMapTransfrm[IndexFirstPoint+1])/VectorScalar;
Obser[2]=(Oprime[2]-IsoPointMapTransfrm[IndexFirstPoint+2])/VectorScalar;

/// Cosinus computation:

cosinus=
(Obser[0]*NormTransfrm[ThreeTimesI  ] +
 Obser[1]*NormTransfrm[ThreeTimesI+1] +
 Obser[2]*NormTransfrm[ThreeTimesI+2] );

/*
/// This cosinus works also but it's not as accurate as the one before
cosinus=
(Obser[0]*(IsoNormOriginal[IndexFirstPoint  ]+IsoNormOriginal[IndexSecondPoint  ]+IsoNormOriginal[IndexThirdPoint  ])/3 +
 Obser[1]*(IsoNormOriginal[IndexFirstPoint+1]+IsoNormOriginal[IndexSecondPoint+1]+IsoNormOriginal[IndexThirdPoint+1])/3 +
 Obser[2]*(IsoNormOriginal[IndexFirstPoint+2]+IsoNormOriginal[IndexSecondPoint+2]+IsoNormOriginal[IndexThirdPoint+2])/3 );
*/
/// Just in case...must be changed
if(cosinus >  1) cosinus = 1;
if(cosinus < -1) cosinus =-1;

///                      TRIAGE des POLYGONES
///========== triage des polygone selon leurs veleurs Z et creation d'une liste
///========== de polygones TRIES qu'on utilisera apres pour l'affichage final.

CurrentTriangle = i;
/*
//TriangleIndex = 3*IsoSurfaceTriangleListe[ThreeTimesI  ];
tableaureferences[CurrentTriangle]->setPoint(0,
  (int)(IsoPointMapProjectd[IndexFirstPoint  ]  ),
  (int)(IsoPointMapProjectd[IndexFirstPoint+1]));

//TriangleIndex = 3*IsoSurfaceTriangleListe[ThreeTimesI+1];
tableaureferences[CurrentTriangle]->setPoint(1,
  (int)(IsoPointMapProjectd[IndexSecondPoint  ]  ),
  (int)(IsoPointMapProjectd[IndexSecondPoint+1]  ));

tableaureferences[CurrentTriangle]->setPoint(2,
  (int)(IsoPointMapProjectd[IndexThirdPoint  ]  ),
  (int)(IsoPointMapProjectd[IndexThirdPoint+1]  ));
*/
tableaureferences[CurrentTriangle]->putPoints(0, 3,
(int)(IsoPointMapProjectd[IndexFirstPoint  ]),
(int)(IsoPointMapProjectd[IndexFirstPoint+1]),
(int)(IsoPointMapProjectd[IndexSecondPoint  ]),
(int)(IsoPointMapProjectd[IndexSecondPoint+1]),
(int)(IsoPointMapProjectd[IndexThirdPoint  ]),
(int)(IsoPointMapProjectd[IndexThirdPoint+1]));

///=============  Triage des Triangles selon la valeurs de leurs profondeurs Z ====

 itVectorData = VectorIsoTriangle.begin();
 tmp=0;
 nb_triangle = VectorIsoTriangle.size();

if( nb_triangle > 0)
{
           while( tmp < nb_triangle) {
               if( z_tmp < VectorIsoTriangle[tmp]->valeur_z )
  {
  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z = z_tmp;
  tableau[CurrentTriangle].valeur_cos = cosinus;
  tableau[CurrentTriangle].TypeCND = TypeIsoSurfaceTriangleListeCND[i];

  VectorIsoTriangle.insert(itVectorData, &tableau[CurrentTriangle]);
  tmp = nb_triangle ;
  }

  else   {
      if( tmp==(nb_triangle -1)) {

  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z = z_tmp;
  tableau[CurrentTriangle].valeur_cos = cosinus;
  tableau[CurrentTriangle].TypeCND = TypeIsoSurfaceTriangleListeCND[i];

  VectorIsoTriangle.push_back(&tableau[CurrentTriangle]);
  tmp = nb_triangle ;
                             }
      else    {
      tmp++ ;
      itVectorData++;
      }
                      }
                      }
}
else {
  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z =  z_tmp;
  tableau[CurrentTriangle].valeur_cos = cosinus;
  tableau[CurrentTriangle].TypeCND = TypeIsoSurfaceTriangleListeCND[i];

  VectorIsoTriangle.push_back(&tableau[CurrentTriangle]);
}

} /// End of if(z_tmp < 460 || clipping == -1)
} /// End of for ( i=0; i < NbTriangleIsoSurface ...




///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++///
/// Now we add the axe to the Iso Surface...











if(DrawAxe_Ok == 1) {
for(j = 0; j <3; j++)
for ( i=0; i < 38 ; ++i) {

ThreeTimesI = 3*i;

z_tmp = (AxeArrayTransfrm[j][i*3 + 2]+
         AxeArrayTransfrm[j][(i+1)*3 +2])/2;
if(z_tmp < 460 )
{


/// All 3D Axes are placed at the end of of the 'tableaureferences' Array

CurrentTriangle = (j*50) + i + 8000;

tableaureferences[CurrentTriangle]->putPoints(0, 3,
(int)(AxeArrayProjectd[j][i*3      ]),
(int)(AxeArrayProjectd[j][i*3    +1]),
(int)(AxeArrayProjectd[j][(i+1)*3  ]),
(int)(AxeArrayProjectd[j][(i+1)*3+1]),
(int)(AxeArrayProjectd[j][(i+1)*3  ]),
(int)(AxeArrayProjectd[j][(i+1)*3+1]));



///=============  Triage des Triangles selon la valeurs de leurs profondeurs Z ====

 itVectorData = VectorIsoTriangle.begin();
 tmp=0;
 nb_triangle = VectorIsoTriangle.size();

if( nb_triangle > 0)
{
           while( tmp < nb_triangle) {
               if( z_tmp < VectorIsoTriangle[tmp]->valeur_z )
  {
  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z = z_tmp;
  //tableau[CurrentTriangle].valeur_cos = 0.000333777 + (j*0.111);
  tableau[CurrentTriangle].TypeCND = 10+j;

  VectorIsoTriangle.insert(itVectorData, &tableau[CurrentTriangle]);
  tmp = nb_triangle ;
  }

  else   {
      if( tmp==(nb_triangle -1)) {

  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z = z_tmp;
  //tableau[CurrentTriangle].valeur_cos = 0.000333777 + (j*0.111);
  tableau[CurrentTriangle].TypeCND = 10+j;

  VectorIsoTriangle.push_back(&tableau[CurrentTriangle]);
  tmp = nb_triangle ;
                             }
      else    {
      tmp++ ;
      itVectorData++;
      }
                      }
                      }
}
else {
  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z =  z_tmp;
  //tableau[CurrentTriangle].valeur_cos = 0.000333777 + (j*0.111);
  tableau[CurrentTriangle].TypeCND = 10+j;

  VectorIsoTriangle.push_back(&tableau[CurrentTriangle]);
}

} /// End of if (z_tmp < 460)
}

///++++++++++++++++++++++++++++++++++++++++++++++++++///

/// Now we add the arrows for the 3D axes :

for(j = 0; j <3; j++) {


z_tmp = (AxeArrayTransfrm[j][39*3+2]+
         AxeArrayTransfrm[j][40*3+2]+
         AxeArrayTransfrm[j][41*3+2])/3;
if(z_tmp < 460 )
{


/// All 3D Axes are placed at the end of of the 'tableaureferences' Array

CurrentTriangle = (j*50) + 39 + 8000;

tableaureferences[CurrentTriangle]->putPoints(0, 3,
(int)(AxeArrayProjectd[j][39*3  ]),
(int)(AxeArrayProjectd[j][39*3+1]),
(int)(AxeArrayProjectd[j][40*3  ]),
(int)(AxeArrayProjectd[j][40*3+1]),
(int)(AxeArrayProjectd[j][41*3  ]),
(int)(AxeArrayProjectd[j][41*3+1]));



///=============  Triage des Triangles selon la valeurs de leurs profondeurs Z ====

 itVectorData = VectorIsoTriangle.begin();
 tmp=0;
 nb_triangle = VectorIsoTriangle.size();

if( nb_triangle > 0)
{
           while( tmp < nb_triangle) {
               if( z_tmp < VectorIsoTriangle[tmp]->valeur_z )
  {
  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z = z_tmp;
  //tableau[CurrentTriangle].valeur_cos = 0.0000000001 +j*0.0000000001;
  tableau[CurrentTriangle].TypeCND = 13+j;

  VectorIsoTriangle.insert(itVectorData, &tableau[CurrentTriangle]);
  tmp = nb_triangle ;
  }

  else   {
      if( tmp==(nb_triangle -1)) {

  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z = z_tmp;
  //tableau[CurrentTriangle].valeur_cos = 0.0000000001 +j*0.0000000001;
  tableau[CurrentTriangle].TypeCND = 13+j;

  VectorIsoTriangle.push_back(&tableau[CurrentTriangle]);
  tmp = nb_triangle ;
                             }
      else    {
      tmp++ ;
      itVectorData++;
      }
                      }
                      }
}
else {
  tableau[CurrentTriangle].pl = tableaureferences[CurrentTriangle];
  tableau[CurrentTriangle].valeur_z =  z_tmp;
  //tableau[CurrentTriangle].valeur_cos = 0.0000000001 +j*0.0000000001;
  tableau[CurrentTriangle].TypeCND = 13+j;

  VectorIsoTriangle.push_back(&tableau[CurrentTriangle]);
}

} /// End of if (z_tmp < 460)

}
}

/// End of the condtruction of the vector

/// ++++++++++++++ Draw the vector of triangles ++++++++++++++

IsoTriangle * CurrentTrianglePt;
QPointArray * CurrentQPointArrayPt;
double        CurrentCosinusValue;
int TriangleType;
QPen gridcol(QColor(gridr,gridg,gridb), 1);
QPen red(QColor(255,0,0), axe_width),
     green(QColor(0, 255, 0), axe_width),
     blue(QColor(0, 0, 255), axe_width) ,
     CNDred(QColor(255,0,0), 1),
     WhiteBorder(QColor(255, 255, 255), 5);
QBrush redone(QColor(255, 0 ,0));
redone.setStyle(Qt::HorPattern);

QBrush CND(QColor(200, 0 ,0));
QBrush CNDG(QColor(200, 200 ,200));

QBrush greenone(QColor(0, 255, 0));
greenone.setStyle(Qt::HorPattern);

QBrush blueone(QColor(0, 0, 255));
blueone.setStyle(Qt::HorPattern);


nb_triangle = VectorIsoTriangle.size();
/*
if (gridtransparent == 1 ) g.setPen( Qt::NoPen );
else g.setPen( gridcol );
*/
if (gridtransparent == 1 ) gridcol = Qt::NoPen ;
g.setPen( gridcol );

 for(i=0; i< nb_triangle ; i++) {
CurrentTrianglePt    = VectorIsoTriangle.at(i);
CurrentQPointArrayPt = CurrentTrianglePt->pl;
CurrentCosinusValue  = CurrentTrianglePt->valeur_cos;
TriangleType         = CurrentTrianglePt->TypeCND;

switch (TriangleType){
/// First case: Normal triangles...
case 1 :
            if(IsoMesh != 1) {
CurrentCosinusValue > 0 ? g.setBrush(palette_front_face[(int)(CurrentCosinusValue*255)]) :
g.setBrush(palette_back_face[(int)(-CurrentCosinusValue*255)]);
g.drawPolygon(*CurrentQPointArrayPt);
                             }
            else {
g.drawPolyline(*CurrentQPointArrayPt);
g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(2));
            }
        break;
/// Second Case : CND region draw
case 0 : if(CNDDraw == 1) {
if(CNDMesh == 1) {
CurrentCosinusValue > 0 ?
g.setBrush(palette_CND[(int)(CurrentCosinusValue*255)]) :
g.setBrush(palette_CND[(int)(-CurrentCosinusValue*255)]);
g.drawPolygon(*CurrentQPointArrayPt);
                  }
else {
            g.setPen( CNDred);
            g.drawPolyline(*CurrentQPointArrayPt);
            g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(2));
            g.setPen( gridcol );
     }
}
break;

case 4 :
if(BorderDraw == 1)  {
            g.setPen( WhiteBorder );
            g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(1));
            g.setPen( gridcol );
                     }
break;

case 10 :
g.setPen( red);
g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(1));
//g.drawPolyline(*CurrentQPointArrayPt);
g.setPen( gridcol );
break;

case 11 :
g.setPen( green );
g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(1));
//g.drawPolyline(*CurrentQPointArrayPt);
g.setPen( gridcol );
break;

case 12 :
g.setPen( blue );
g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(1));
//g.drawPolyline(*CurrentQPointArrayPt);
g.setPen( gridcol );
break;

case 13 :
g.setPen( red );
g.setBrush(redone);
g.drawPolygon(*CurrentQPointArrayPt);
g.drawText((int)(2*AxeArrayProjectd[0][39*3  ] - AxeArrayProjectd[0][38*3  ]),
           (int)(2*AxeArrayProjectd[0][39*3+1] - AxeArrayProjectd[0][38*3+1]),
           "X");
g.setPen( gridcol );
break;
case 14 :
g.setPen( green );
g.setBrush(greenone);
g.drawPolygon(*CurrentQPointArrayPt);
g.drawText((int)(2*AxeArrayProjectd[1][39*3  ] - AxeArrayProjectd[1][38*3  ]),
           (int)(2*AxeArrayProjectd[1][39*3+1] - AxeArrayProjectd[1][38*3+1]),
           "Y");
g.setPen( gridcol );
break;

case 15:
g.setPen(blue );
g.setBrush(blueone);
g.drawPolygon(*CurrentQPointArrayPt);
g.drawText((int)(2*AxeArrayProjectd[2][39*3  ] - AxeArrayProjectd[2][38*3  ]),
           (int)(2*AxeArrayProjectd[2][39*3+1] - AxeArrayProjectd[2][38*3+1]),
           "Z");
g.setPen( gridcol );
break;

}
}

/*



if( DrawAxe_Ok != 1){
if(IsoMesh != 1 )
    for(i=0; i< nb_triangle ; i++) {
CurrentTrianglePt    = VectorIsoTriangle.at(i);
CurrentQPointArrayPt = CurrentTrianglePt->pl;
CurrentCosinusValue  = CurrentTrianglePt->valeur_cos;
TriangleType         = CurrentTrianglePt->TypeCND;
if((IsoConditionRequired !=1 ) || TriangleType == 1) {
if(CurrentCosinusValue > 0)
g.setBrush(palette_front_face[(int)(CurrentCosinusValue*255)]);
else g.setBrush(palette_back_face[-(int)(CurrentCosinusValue*255)]);
g.drawPolygon(*CurrentQPointArrayPt);
}
else {
if(CNDDraw == 1) {

if(TriangleType == 0)  {
CurrentCosinusValue > 0 ? g.setBrush(palette_CND[(int)(CurrentCosinusValue*255)]) :
                          g.setBrush(palette_CND[(int)(-CurrentCosinusValue*255)]);
//else g.setBrush(CNDG); /// Border (White)


            if(CNDMesh == 1)
            g.drawPolygon(*CurrentQPointArrayPt);
            else {
            g.setPen( CNDred);
            g.drawPolyline(*CurrentQPointArrayPt);
            g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(2));
            g.setPen( gridcol );
            }
}
else if(BorderDraw == 1 && TriangleType == 4)  {
            g.setPen( WhiteBorder );
            g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(1));
            g.setPen( gridcol );
}
}/// End of if(CNDDraw == 1)...
}


}
else
    for(i=0; i< nb_triangle ; i++) {
CurrentTrianglePt    = VectorIsoTriangle.at(i);
CurrentQPointArrayPt = CurrentTrianglePt->pl;
CurrentCosinusValue  = CurrentTrianglePt->valeur_cos;

g.drawPolyline(*CurrentQPointArrayPt);
g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(2));

} /// End of if( DrawAxe_Ok != 1)...
}
/// We have to draw the 3D axes
else {


    for(i=0; i< nb_triangle ; i++) {
CurrentTrianglePt    = VectorIsoTriangle.at(i);
CurrentQPointArrayPt = CurrentTrianglePt->pl;
CurrentCosinusValue  = CurrentTrianglePt->valeur_cos;
     if ( CurrentCosinusValue == 0.000333777) {
g.setPen( red);
g.drawPolyline(*CurrentQPointArrayPt);
g.setPen( gridcol );

}
else if ( CurrentCosinusValue == 0.111333777) {
g.setPen( green );
g.drawPolyline(*CurrentQPointArrayPt);
g.setPen( gridcol );

}
else if ( CurrentCosinusValue == 0.222333777) {
g.setPen( blue );
g.drawPolyline(*CurrentQPointArrayPt);
g.setPen( gridcol );

}
else if ( CurrentCosinusValue == 0.0000000001) {
g.setPen( red );
g.setBrush(redone);
g.drawPolygon(*CurrentQPointArrayPt);
g.drawText((int)(2*AxeArrayProjectd[0][39*3  ] - AxeArrayProjectd[0][38*3  ]),
           (int)(2*AxeArrayProjectd[0][39*3+1] - AxeArrayProjectd[0][38*3+1]),
           "X");
g.setPen( gridcol );
}
else if ( CurrentCosinusValue == 0.0000000002) {
g.setPen( green );
g.setBrush(greenone);
g.drawPolygon(*CurrentQPointArrayPt);
g.drawText((int)(2*AxeArrayProjectd[1][39*3  ] - AxeArrayProjectd[1][38*3  ]),
           (int)(2*AxeArrayProjectd[1][39*3+1] - AxeArrayProjectd[1][38*3+1]),
           "Y");
g.setPen( gridcol );
}
else if ( CurrentCosinusValue == 0.0000000003) {
g.setPen(blue );
g.setBrush(blueone);
g.drawPolygon(*CurrentQPointArrayPt);
g.drawText((int)(2*AxeArrayProjectd[2][39*3  ] - AxeArrayProjectd[2][38*3  ]),
           (int)(2*AxeArrayProjectd[2][39*3+1] - AxeArrayProjectd[2][38*3+1]),
           "Z");
g.setPen( gridcol );
}




else {
if (gridtransparent == 1 ) g.setPen( Qt::NoPen );
else g.setPen( gridcol );

if(IsoMesh != 1 ){
if(CurrentCosinusValue > 0)
g.setBrush(palette_front_face[(int)(CurrentCosinusValue*255)]);
else g.setBrush(palette_back_face[-(int)(CurrentCosinusValue*255)]);
g.drawPolygon(*CurrentQPointArrayPt);
}
else  {
g.drawPolyline(*CurrentQPointArrayPt);
g.drawLine ( CurrentQPointArrayPt->point(0), CurrentQPointArrayPt->point(2));
} /// End of if( DrawAxe_Ok != 1)...
}
}
}
*/
/// End of the The Drawing of the vector
/// delete the vector
VectorIsoTriangle.clear();
/// Infos :
if( IsoInfos ==1 ){

g.setPen(QColor(250,0,0));
g.drawText(5,15,"           "+QString::number(nb_ligne)+" x "+QString::number(nb_colon)+" x "+QString::number(nb_depth));

g.setPen(QColor(0,250,0));
g.drawText(5,
           15,
           "Grid = ");


g.setPen(QColor(250,0,0));
g.drawText(5,30,"                 "+QString::number(nb_triangle));

g.setPen(QColor(0,250,0));
g.drawText(5,
           30,
           "Triangles = ");

g.setPen(QColor(250,0,0));
g.drawText(5,45,"                 "+QString::number(NbPointIsoMap));

g.setPen(QColor(0,250,0));
g.drawText(5,
           45,
           "Points = ");

g.setPen(QColor(250,0,0));
g.drawText(5,60,"                 "+ImplicitFunction);

g.setPen(QColor(0,250,0));
g.drawText(5,
           60,
            "F(x,y,z)   = ");
if(IsoConditionRequired == 1) {
g.setPen(QColor(250,0,0));
g.drawText(5,75,"                 "+IsoCondition);

g.setPen(QColor(0,250,0));
g.drawText(5,
           75,
            "CND      =  ");
}
}
}


